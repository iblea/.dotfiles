fualias() { echo -n ""; }

fuinit() {
fualias $@ ; unset -f fualias; fualias () { echo -n ""; }
}

function function_exist_check() {
    if (declare -f -F "$@" > /dev/null); then
        return 0
    else
        return 1
    fi
}


function cd() {
    builtin cd "$@"
    if [ $? -ne 0 ]; then
        return
    fi
    ls --color=auto -AF
    echo ""
    pwd
}


# enable color support of ls and also add handy aliases
if [ -f $HOME/.dotfiles/.shell_color.sh ]; then
    . $HOME/.dotfiles/.shell_color.sh
elif [ -f $HOME/.shell_color.sh ]; then
    . $HOME/.shell_color.sh
fi

alias grepi="grep --color=auto -rnIH"
alias grepapi="grep --color=auto --exclude-dir=hmapi -rnIH"
alias grepf="grep --color=auto -rnIHF"


# ssh
if [ -f $HOME/.ssh/config ]; then
    alias ssh='ssh -F $HOME/.ssh/config -i $HOME/.ssh/id_rsa -o UserKnownHostsFile=$HOME/.ssh/known_hosts'
    alias scp='scp -F $HOME/.ssh/config -i $HOME/.ssh/id_rsa -o UserKnownHostsFile=$HOME/.ssh/known_hosts'
    alias sshinit='ssh-keygen -f $HOME/.ssh/known_hosts -R '
    alias ibrew="arch -x86_64 /usr/local/bin/brew"
fi

# some more ls aliases
alias ll='ls -lhF'
alias lla='ls -alhF'
alias lf='ls -alhF'
alias jl='ls -lhF'
alias af='ls -lhF'
alias sf='ls -CF'
alias ef='ls -alhF'
alias wf='ls -CF'
alias la='ls -A'
alias l='ls -CF'
alias j='ls -CF'
alias psa='ps -aef'

function psf() {
    process_name="$@"
    ps -aef | head -n1
    ps -aef | grep --color=always "$process_name" | grep -v "grep --color.*always.*$process_name"
}

alias makef='make -j8'
function makeb() {
    result=./compile_commands.json
    if [ -f $result ]; then
        rm -rf $result
    fi
    make clean;
    bear make -j8 --print-directory
    if [ -f $result ]; then
        if [ -d ./.vscode ]; then
            mv $result ./.vscode/
            echo "mv $result"
        fi
    fi
    echo "bear compile done"
}

# add export path
if ! grep -q "$HOME/.local/.bin" <<< "$PATH"; then
    export PATH="$PATH:$HOME/.local/.bin"
fi

if [[ "$(command -v 'code-insiders')" != "" ]]; then
    alias code='code-insiders'
fi

# =======================================================================

# wsl command
if [ -n "$(uname -r | grep 'WSL')" ]; then
    if [ "$(command -v code)" = "" ]; then
        local codepath="/mnt/c/jvscode/Code.exe"
        if [ -f $codepath ] && [ ! -f $HOME/.local/.bin/code ]; then
            [ ! -d $HOME/.local/.bin/ ] && mkdir -p $HOME/.local/.bin/
            ln -s $codepath $HOME/.local/.bin/code
        fi
    fi

    # windows + explorer
    function epl() {
        if [[ "$@" = "" ]]; then
            /mnt/c/WINDOWS/explorer.exe .
            return
        fi
        if [ -d "$@" ]; then
            builtin cd "$@"
            /mnt/c/WINDOWS/explorer.exe .
            builtin cd - > /dev/null
            return
        fi
        /mnt/c/WINDOWS/explorer.exe .
    }

    # function code() {
    #     if [[ "$@" = "s" ]]; then
    #         /mnt/c/jvscode/Code.exe ./
    #     else
    #         /mnt/c/jvscode/Code.exe $@
    #     fi
    # }

    function goc() { cd /mnt/c/$@; }
    function god() { cd /mnt/d/$@; }
    function goe() { cd /mnt/e/$@; }
    function govscode() { cd /mnt/c/jvscode/data/user-data/User/$@; }
    function gohome() { cd /mnt/c/Users/ghkd0/$@; }
    function golog() { cd /mnt/e/mylog/$@; }
    function godown() { cd /mnt/c/Users/ghkd0/Downloads/$@; }
    function godesktop() { cd /mnt/c/Users/ghkd0/Desktop/$@; }

    # "/mnt/c/Program\\ Files/Beyond\\ Compare\\ 4/BComp.exe"
    # alias diffb='"/mnt/c/Program Files/Beyond Compare 4/BComp.exe"'
    alias diffb='~/.bcomp.sh'

    alias curla="/mnt/c/Users/ghkd0/Videos/.aaa_testcurl.sh"
    alias curlq="/mnt/c/Users/ghkd0/Videos/.qqq_testcurl.sh"
    alias curls="/mnt/c/Users/ghkd0/Videos/.rrr_testcurl.sh"

    [[ "$TERM_PROGRAM" != "vscode" ]] && (builtin cd $HOME)
# mac command
elif [[ "$(uname -s)" = "Darwin" ]]; then
    # alias code="/Applications/'Visual Studio Code.app'/Contents/Resources/app/bin/code"
    export PATH="$PATH:/Applications/Visual Studio Code.app/Contents/Resources/app/bin"
    # alias diffb='~/.bcomp'

    # macos
    if [ -d "/Applications/Hex Fiend.app" ]; then
        alias hxd='open -a /Applications/Hex\ Fiend.app'
    fi
    alias diffb='"/Applications/Beyond Compare.app/Contents/MacOS/BComp"'
    alias which="$(/bin/bash -c 'which which' 2>/dev/null)"
    alias ldd="otool -L"


    # vim -> mvim, nvim
    if [ -d "/Applications/MacVim.app/" ]; then
        alias mvi='/Applications/MacVim.app/Contents/bin/vim'
        alias mvim='/Applications/MacVim.app/Contents/bin/mvim'
        alias macvim='/Applications/MacVim.app/Contents/bin/vim'
        alias vi="/Applications/MacVim.app/Contents/bin/vim"
        alias vim="/Applications/MacVim.app/Contents/bin/vim"
    elif [ -n "$(which nvim)" ]; then
        alias nvi='nvim'
        alias vi='nvim'
        alias vim='nvim'
    fi

    # brew install findutils
    if [ -f /opt/homebrew/bin/gxargs ]; then
        alias xargs="/opt/homebrew/bin/gxargs"
    fi

    function godown() { cd $HOME/Downloads/$@; }
    function godoc() { cd $HOME/Documents/$@; }
    function gonote() { cd $HOME/.notepad/$@; }
    function gont() { cd $HOME/.notepad/$@; }
    # go google drive
    function gogd() { cd "/Users/jdh/GoogleDrive/$@"; }
    function godrive() { cd "/Users/jdh/GoogleDrive/$@"; }
    function goicloud() { cd "/Users/jdh/Library/Mobile Documents/com~apple~CloudDocs/$@"; }
    function goissue() { cd $HOME/issue/$@; }

    # ppk to pem
    function ppktopem() {
        if [ "$(command -v puttygen)" = "" ]; then
            echo "install putty first"
            echo "brew install putty"
            return
        fi
        filename=$@
        extname="${filename:$(expr ${#filename} - 4)}"
        if [[ "$extname" != ".ppk" ]]; then
            echo "not ppk file"
            return
        fi
        pemname=$(echo "$filename" | sed 's/.ppk$/.pem/')
        puttygen "$filename" -O private-openssh -o "$pemname"
    }

    function pemtoppk() {
        if [ "$(command -v puttygen)" = "" ]; then
            echo "install putty first"
            echo "brew install putty"
            return
        fi
        filename=$@
        puttygen "$filename" -o "${filename}.ppk"
    }

    function ddns_set() {
        ddns_script_path="$HOME/GoogleDrive/develop/settings/ddns_google.sh"
        if [ ! -x $ddns_script_path ]; then
            echo "$ddns_script_path"
            echo "not found ddns script path"
            exit 1
        fi
        "$ddns_script_path" "$1" "$2"
    }

    function ddnsvi() {
        ddns_script_path="$HOME/GoogleDrive/develop/settings/ddns_google.sh"
        if [ ! -x $ddns_script_path ]; then
            echo "$ddns_script_path"
            echo "not found ddns script path"
            exit 1
        fi
        vim "$ddns_script_path"
    }
    alias keyvi="vi \"$HOME/GoogleDrive/keys/keys.txt\""


    alias gosrc="cd $HOME/src"
    # cd practice directory
    alias gotest="cd $HOME/src/testsrc"
    alias gocert="cd $HOME/Documents/cert"

    alias curla="$HOME/curltest/.aaa_testcurl.sh"
    alias curlq="$HOME/curltest/.qqq_testcurl.sh"
    alias curle="$HOME/curltest/.eee_testcurl.sh"
    alias curlr="$HOME/curltest/.rrr_testcurl.sh"
    alias curlavi="vim $HOME/curltest/.aaa_testcurl.sh"
    alias curlqvi="vim $HOME/curltest/.qqq_testcurl.sh"
    alias curlevi="vim $HOME/curltest/.eee_testcurl.sh"
    alias curlrvi="vim $HOME/curltest/.rrr_testcurl.sh"
    alias dockoff="defaults write com.apple.dock autohide-delay -float 1000; killall Dock"
    alias dockon="defaults delete com.apple.dock autohide-delay; killall Dock"

    # explorer
    alias epl="open ."
    alias expl="open ."
else
    alias diffb='~/.bcomp.sh'
fi

# =======================================================================







# diffdirectory - diffdir
function diffdir()
{
    directory_1="v5.0"
    directory_2="v5.0.2_2"

    file1="$directory_1/$@"
    file2="$directory_2/$@"
    if [ ! -f $file1 ]; then
        echo "$file1 not exist"
        return
    elif [ ! -f $file2 ]; then
        echo "$file2 not exist"
        return
    fi

    diffb "$file1" "$file2"
}

# absolute path
alias abs='readlink -e'

function grepn() {
    local search_str=("$@")
    if [[ "$1" = "exai" ]]; then
        search_str=("--exclude-dir=ailib" "${@:2}")
    fi
    if [[ "$1" = "extab" ]]; then
        search_str=("--exclude=parse.tab.c" "${@:2}")
    fi

    # -P option : perl regex
    # grep --color=always -rnIH ${search_str[@]} | sed -e "p" -e "s/:/ | /2" | sed -n "2~2p"
    # grep --color=always -rnIH ${search_str[@]} | sed -e "s/:/ | /2" -e "s|\[m\[K\s*|[m[K|g"
    # grep --color=always -rnIH ${search_str[@]} | sed -e "s/:/ | /2"
    grep --color=always -rnIH ${search_str[@]} | sed -e "s/\:\[m\[K\s*/ |[m[K /2"
}

function grepm() {
    local search_str=("$@")
    if [[ "$1" = "exai" ]]; then
        search_str=("--exclude-dir=ailib" "${@:2}")
    fi
    if [[ "$1" = "extab" ]]; then
        search_str=("--exclude=parse.tab.c" "${@:2}")
    fi

    # grep --color=always -rnIHF ${search_str[@]} | sed -e "s/:/ | /2" -e "s|\[m\[K\s*|[m[K|g"
    # grep --color=always -rnIHF ${search_str[@]} | sed -e "s/:/ | /2"
    grep --color=always -rnIHF ${search_str[@]} | sed -e "s/\:\[m\[K\s*/ |[m[K /2"
}

# absolute path grep
function agrepn() {
    local curpwd=$(pwd);
    local search_str=("$@")
    if [[ "$curpwd" != "/" ]]; then
        curpwd="${curpwd}/"
    fi
    if [[ "$1" = "exai" ]]; then
        search_str=("--exclude-dir=ailib" "${@:2}")
    fi
    if [[ "$1" = "extab" ]]; then
        search_str=("--exclude=parse.tab.c" "${@:2}")
    fi

    # grep --color=always -rnIH ${search_str[@]} | sed -e "s|^|${curpwd}|1" -e "s/\:/\n/2" -e "s|\[m\[K\s*|[m[K|g"
    # grep --color=always -rnIH ${search_str[@]} | sed -e "s|^|${curpwd}|1" -e "s/\:/\n/2"
    grep --color=always -rnIH ${search_str[@]} | sed -e "s|^|${curpwd}|1" -e "s|\:\[m\[K\s*|[m[K\n|2"
}
function agrepm() {
    local curpwd=$(pwd);
    local search_str=("$@")
    if [[ "$curpwd" != "/" ]]; then
        curpwd="${curpwd}/"
    fi
    if [[ "$1" = "exai" ]]; then
        search_str=("--exclude-dir=ailib" "${@:2}")
    fi
    if [[ "$1" = "extab" ]]; then
        search_str=("--exclude=parse.tab.c" "${@:2}")
    fi

    # grep --color=always -rnIHF ${search_str[@]} | sed -e "s|^|${curpwd}|1" -e "s/\:/\n/2" -e "s|\[m\[K\s*|[m[K|g"
    # grep --color=always -rnIHF ${search_str[@]} | sed -e "s|^|${curpwd}|1" -e "s/\:/\n/2"
    grep --color=always -rnIHF ${search_str[@]} | sed -e "s|^|${curpwd}|1" -e "s|\:\[m\[K\s*|[m[K\n|2"
}

# fzfcode
if [ "$(command -v fzf)" != "" ]; then
    if (alias fzf >/dev/null 2>&1); then
        unalias fzf
    fi
    alias fzf="fzf --height 40% --layout=reverse"
    # if (declare -f -F "$@" > /dev/null); then
    #     unset -f fzf
    # fi
    # whence -p fzf # command in zsh
    # local FU_FZF_BIN_PATH="$(/bin/which fzf)"
    function faf() {
        # TODO : -m Îì± ÏòµÏÖòÍ∞í Ï≤òÎ¶¨ÌïòÏßÄ Î™ªÌï®. Ìï¥Îãπ Î∞©Î≤ï Î™®ÏÉâ
        # local FU_FZF_BIN_PATH="$(/bin/which fzf)"
        [ $# -ge 2 ] && echo "too many arguments" && return
        if [ $# -eq 1 ]; then
            if [ ! -d "$@" ]; then
                echo "$@ not directory"
                return
            fi
            builtin cd $@
            fzf --height 40% --layout=reverse
            builtin cd - > /dev/null
            return
        fi
        fzf --height 40% --layout=reverse
    }
    # Í∏∞Ï°¥ alias Í∞Ä ÏûàÏùÑ Í≤ΩÏö∞ ÏÇ≠Ï†ú

    # alias di='fzfoutput=$(fzf); [ "$fzfoutput" != "" ] && code $fzfoutput; unset fzfoutput'
    # code+vi = di
    # fzf di
    function di()
    {
        local codepath=vi
        local codeopt=""
        [ "$(command -v code)" != "" ] && codepath=code
        [ "$(command -v 'code-insiders')" != "" ] && codepath=code-insiders
        [ "$(command -v cursor)" != "" ] && codepath=cursor
        local WHICH_IS=$(/bin/bash -c "which which" 2>/dev/null)
        local FZF_BIN_PATH=$($WHICH_IS fzf)
        # argument Í∞Ä 2Í∞ú Ïù¥ÏÉÅÏùº Í≤ΩÏö∞
        if [ $# -ge 2 ]; then
            local search_path=()
            if [ "$1" = "touch" ]; then
                for arg in "${@:2}"; do
                    if [ -d "$arg" ]; then
                        echo "\"$arg\" is directory (so skip)"
                        continue
                    fi
                    search_path+=("$arg")
                done
                $codepath $codeopt "${search_path[@]}"
                return ;
            fi
            is_first=1
            for arg in "$@"; do
                if [ $is_first -eq 1 ]; then
                    is_first=0
                    if [[ "$codepath" = "vi" ]]; then
                        continue
                    fi
                    if [[ "$arg" = "-g" ]] || [[ "$arg" = "--goto" ]]; then
                        codeopt="--goto"
                        continue
                    fi
                fi
                if [ -d "$arg" ]; then
                    echo "\"$arg\" is directory (so skip)"
                    continue
                fi
                if [ ! -e "$arg" ]; then
                    onlyfile=""
                    if [ "$codepath" != "vi" ]; then
                        onlyfile=$(echo "$arg" | sed 's/:[0-9]*$//')
                        # onlyfile="${arg%:*}"
                        # onlyfile=$(echo "$arg" | awk -F":" '{NF=NF-1}1' OFS=":")
                    fi
                    if [ -e "$onlyfile" ]; then
                        codeopt="--goto"
                    else
                        echo "file not found. create new file? (ctrl-c to stop)"
                        read $anykey
                    fi
                fi
                search_path+=("$arg")
            done
            $codepath $codeopt "${search_path[@]}"
            return ;
        fi
        # argumentÍ∞Ä 1Í∞úÏùº Í≤ΩÏö∞
        if [ $# -eq 1 ]; then
            if [ -d "$@" ]; then
                # Ìï¥Îãπ ÎîîÎ†âÌÜ†Î¶¨Î°ú Ïù¥ÎèôÌïòÏó¨ Í≤ÄÏÉâ
                builtin cd $@
            elif [[ "$@" = "-" ]]; then
                rm -f /tmp/code-stdin-*
                codeopt="--goto"
                $codepath $codeopt $@ &
                return
            else
                if [ ! -e "$@" ]; then
                    if [ "$codepath" != "vi" ]; then
                        onlyfile=$(echo "$@" | sed 's/:[0-9]*$//')
                        if [ -e "$onlyfile" ]; then
                            codeopt="--goto"
                            $codepath $codeopt $@
                            return
                        fi
                    fi
                    fzfres=""
                    getname=$(echo "$@" | awk -F '/' '{ print $NF }')
                    if [[ "${FZF_DEFAULT_COMMAND:0:2}" = "fd" ]]; then
                        tmpcmd="fd \"$getname\" --type file --follow --hidden --no-ignore -X grep -lI ."
                    else
                        tmpcmd="find . -name \"$getname\" -type f -exec grep -lI . {} \;"
                    fi
                    fzfres=$(FZF_DEFAULT_COMMAND="$tmpcmd" $FZF_BIN_PATH --height 40% --layout=reverse --preview 'cat {}')
                    # FZF_DEFAULT_COMMAND="fd \"inspection_\" --type file --follow --hidden --no-ignore -X grep -lI ." fzf
                    if [ "$fzfres" != "" ]; then
                        $codepath $codeopt $fzfres
                    fi
                    return
                    # skip new file
                    # echo "file not found. create new file? (ctrl-c to stop)"
                    # read $anykey
                fi
                # 1Í∞úÏù¥Í≥† ÎîîÎ†âÌÜ†Î¶¨Í∞Ä ÏïÑÎãàÎ©¥ Î∞îÎ°ú Ïã§Ìñâ
                $codepath $codeopt $@
                return
            fi
        fi
        # find Ïùò Í≤ΩÏö∞ '! -name "*.o"' Î°ú ÏÇ¨Ïö©
        local exclude_pot=''
        if [ "$FZF_DEFAULT_COMMAND" = "" ]; then
            exclude_opt=''
        elif [ "${FZF_DEFAULT_COMMAND:0:2}" = "fd" ]; then
            exclude_opt='-E ".git"'
        elif [ "${FZF_DEFAULT_COMMAND:0:4}" = "find" ]; then
            exclude_opt='! -name ".git"'
        else
            exclude_opt=''
        fi
        local origin_fzf_cmd=$(echo "$FZF_DEFAULT_COMMAND")
        export FZF_DEFAULT_COMMAND="$FZF_DEFAULT_COMMAND $exclude_opt"
        local fzfres=""
        # pipelineÏúºÎ°ú ÏûÖÎ†•Ïù¥ Îì§Ïñ¥Ïò® Í≤ΩÏö∞
        if [ -p /dev/stdin ]; then
            cat < /dev/stdin > $HOME/.dotfiles/.fzfinput
            sleep 0.05
            fzfres=$(cat $HOME/.dotfiles/.fzfinput | $FZF_BIN_PATH --height 40% --layout=reverse  --preview 'cat {}')
            [ -f $HOME/.dotfiles/.fzfinput ] && rm -f $HOME/.dotfiles/.fzfinput
            if [ -d "$fzfres" ]; then
                echo "$fzfres is directory (so skip)"
                return
            fi
        else
            fzfres=$($FZF_BIN_PATH --height 40% --layout=reverse  --preview 'cat {}')
        fi
        if [ "$fzfres" != "" ]; then
            $codepath $codeopt $fzfres
        fi
        export FZF_DEFAULT_COMMAND="$origin_fzf_cmd"
        # ÎîîÎ†âÌÜ†Î¶¨ Ïù¥ÎèôÌñàÏùÑ Í≤ΩÏö∞ ÏõêÎûò ÎîîÎ†âÌÜ†Î¶¨Î°ú Ïù¥Îèô
        [ $# -eq 1 ] && builtin cd - > /dev/null
    }
else
    # no fzf di
    function di()
    {
        local codepath=vi
        local codeopt=""
        [ "$(command -v code)" != "" ] && codepath=code
        [ "$(command -v 'code-insiders')" != "" ] && codepath=code-insiders
        [ "$(command -v cursor)" != "" ] && codepath=cursor
        # local FZF_BIN_PATH=$(/bin/which fzf)
        # argument Í∞Ä 2Í∞ú Ïù¥ÏÉÅÏùº Í≤ΩÏö∞
        # if [ $# -ge 2 ]; then
        #     local search_path=()
        #     for arg in "$@"; do
        #         if [ "$1" = "touch" ]; then
        #             $codepath $codeopt "${2}"
        #             return ;
        #         fi
        #         if [ -d "$arg" ]; then
        #             echo "\"$arg\" is directory (so skip)"
        #             continue
        #         fi
        #         if [ ! -e "$@" ]; then
        #             echo "file not found. create new file? (ctrl-c to stop)"
        #             read $anykey
        #         fi
        #         search_path+=("$arg")
        #     done
        #     $codepath $codeopt "${search_path[@]}"
        #     return;
        # fi
        if [ $# -ge 2 ]; then
            local search_path=()
            if [ "$1" = "touch" ]; then
                for arg in "${@:2}"; do
                    if [ -d "$arg" ]; then
                        echo "\"$arg\" is directory (so skip)"
                        continue
                    fi
                    search_path+=("$arg")
                done
                $codepath $codeopt "${search_path[@]}"
                return ;
            fi
            is_first=1
            for arg in "$@"; do
                if [ $is_first -eq 1 ]; then
                    is_first=0
                    if [[ "$codepath" = "vi" ]]; then
                        continue
                    fi
                    if [[ "$arg" = "-g" ]] || [[ "$arg" = "--goto" ]]; then
                        codeopt="--goto"
                        continue
                    fi
                fi
                if [ -d "$arg" ]; then
                    echo "\"$arg\" is directory (so skip)"
                    continue
                fi
                if [ ! -e "$arg" ]; then
                    onlyfile=""
                    if [ "$codepath" != "vi" ]; then
                        onlyfile=$(echo "$arg" | sed 's/:[0-9]*$//')
                        # onlyfile="${arg%:*}"
                        # onlyfile=$(echo "$arg" | awk -F":" '{NF=NF-1}1' OFS=":")
                    fi
                    if [ -e "$onlyfile" ]; then
                        codeopt="--goto"
                    else
                        echo "file not found. create new file? (ctrl-c to stop)"
                        read $anykey
                    fi
                fi
                search_path+=("$arg")
            done
            $codepath $codeopt "${search_path[@]}"
            return ;
        fi


        # argumentÍ∞Ä 1Í∞úÏùº Í≤ΩÏö∞
        if [ $# -eq 1 ]; then
            if [ -d "$@" ]; then
                # Ìï¥Îãπ ÎîîÎ†âÌÜ†Î¶¨Î°ú Ïù¥ÎèôÌïòÏó¨ Í≤ÄÏÉâ
                echo "\"$@\" is directory (so skip)"
                return
            elif [[ "$@" = "-" ]]; then
                codeopt="--goto"
                $codepath $codeopt $@
                return
            else
                if [ ! -e "$@" ]; then
                    if [ "$codepath" != "vi" ]; then
                        onlyfile=$(echo "$@" | sed 's/:[0-9]*$//')
                        if [ -e "$onlyfile" ]; then
                            codeopt="--goto"
                            $codepath $codeopt $@
                            return
                        fi
                    fi
                    echo "file not found. create new file? (ctrl-c to stop)"
                    read $anykey
                fi
                # 1Í∞úÏù¥Í≥† ÎîîÎ†âÌÜ†Î¶¨Í∞Ä ÏïÑÎãàÎ©¥ Î∞îÎ°ú Ïã§Ìñâ
                $codepath $codeopt $@
                return
            fi
        fi
        if [ $# -eq 0 ]; then
            echo "no argument"
        fi
    }
fi

function didiff() {
    local codepath=vimdiff
    local codeopt=""
    [ "$(command -v code)" != "" ] && codepath=code && codeopt="--diff"
    [ "$(command -v 'code-insiders')" != "" ] && codepath=code-insiders && codeopt="--diff"
    if [ $# -ne 2 ]; then
        echo "wrong argument"
        return;
    fi
    if [ ! -f "$1" ];then
        echo "'$1' file is not exist"
        return
    fi
    if [ ! -f "$2" ];then
        echo "'$2' file is not exist"
        return
    fi
    $codepath $codeopt "$1" "$2"
}

function encoding_ls()
{
    find . -type f -exec grep -I -q . {} \; -print | xargs -I{} file -i {}
}

function encoding_euckr_to_utf8()
{
    # euc_krs=( $(find . -name "*" -type f -exec file -i {} \; | grep "iso-8859-1" | awk -F ":" '{print $1}') )
    # get not binary file list
    # euckrs=( $(find . -type f -exec grep -I -q . {} \; -print) )
    euc_krs=( $(find . -type f -exec grep -I -q . {} \; -print | xargs -I{} file -i {} | grep "iso-8859-1" | awk -F ":" '{print $1}') )
    for file in "${euc_krs[@]}" ; do
        echo "Converting $file to UTF-8"
        # euc-kr -> utf-8, save to test.c.new
        iconv -c -f euc-kr -t utf-8 "$file" > "$file.new"
        # remove test.c
        rm -f "$file"
        # mv test.c.new test.c
        mv "$file.new" "$file"
    done
}

# alias direj="di $(find . -name '*.rej' -type f | head -n 1 | sed 's/....$//') $(find . -name '*.rej' -type f | head -n 1)"
function direj()
{
    find_result=$(find . -name '*.rej' -type f)
    rej_file=$(echo "$find_result" | head -n 1)
    org_file=$(echo "$rej_file" | sed 's/....$//')
    echo "$rej_file"
    remains=$(echo "$find_result" | wc -l)
    echo "remain : $remains"
    di "$rej_file" "$org_file"
}

function mvrej()
{
    rej_file=$(find . -name '*.rej' -type f | head -n 1)
    echo "$rej_file"
    if [ ! -d $HOME/rej ]; then
        mkdir $HOME/rej/
    fi
    cp --parents $rej_file $HOME/rej/
    rm -f "$rej_file"
}

# rollback rej
function rbrej()
{
    res=$(find $HOME/rej -type f -printf "%T@ %p\n" | sort -n | tail -n1 | cut -d" " -f2-)
    if [ "$rej" = "" ]; then
        echo "empty in rej"
        return ;
    fi
    resto=."$(echo "$res" | sed "s|$HOME/rej||")"
    rb_path="$(dirname $resto)"
    echo $res
    mv "$res" "$rb_path"
}

function toucha() { touch $@; chmod 755 $@; }

function psv() {
    ps -aef | head -n 1
    ps -aef | grep "$@" | grep -v "grep --color=auto $@" | grep "$@"
}

function makectags() { ctags --tag-relative --langmap=C:.c.h.l.y --c-kinds=+p+l --languages=C --fields=+l $@ -f .tags --sort=foldcase -R ./*; }
function makepytags() { ctags --tag-relative --langmap=Python:.py --languages=Python --fields=+l $@ --sort=foldcase -R ./*; }
alias guifiles='vim -c :UpdateTypesFileOnly -c :q'
function maketaghl() {
    if [ ! -f ~/.vim/plugin/TagHighlight.vim ]; then
        echo "no TagHighlight.vim plugin"
        return
    fi
    test ! -f taghl_config.txt && touch taghl_config.txt
    echo "IncludeLocals:True" > taghl_config.txt
    echo "TagFileName:.tags" >> taghl_config.txt
    echo -n "UserLibraries:" >> taghl_config.txt
}

function clearsslkeylog() {
    if [ "$SSLKEYLOGFILE" = "" ]; then
        echo "SSLKEYLOGFILE is not defined"
        return
    fi

    echo -n "" > $SSLKEYLOGFILE
}

# find . ! \( -type d \( -path "./test1" -o -path "./test2" \) -prune \) -type f -and ! -name "LICENSE.txt" -and ! -name "readme.txt" -and -name "*.txt"
# alias findsrc='fualias() { find . ! \( -type d \( -path "./httpgw_oldssl" \) -prune \) -regex ".*\.\(c\|h\|y\|l\|py\)" -type f -exec grep -Hn --color "$@" {} \; ; }; fuinit'
function findsrc() {
    local ext="\(c\|cpp\|h\|y\|l\|py\)"
    find . ! \( -type d \( -path "./httpgw_oldssl" \) -prune \) -regex ".*\.$ext" -type f -exec grep -Hn --color=always "$@" {} \; |
    sed -e "s/\:\[m\[K\s*/ |[m[K /2"
    # sed -e "s/\:/ | /2" -e "s| \| \[m\[K\s*| \| [m[K|"
}

function afindsrc() {
    local curpwd=$(pwd)
    if [[ "$curpwd" != "/" ]]; then
        curpwd="${curpwd}/"
    fi
    local ext="\(c\|cpp\|h\|y\|l\|py\)"
    find . ! \( -type d \( -path "./httpgw_oldssl" \) -prune \) -regex ".*\.$ext" -type f -exec grep -Hn --color=always "$@" {} \; |
    sed -e "s|^|${curpwd}|1" -e "s|\:\[m\[K\s*|[m[K\n|2"
    # sed -e "s|^|${curpwd}|1" -e "s/\:/\n/2" -e "s|\n\[m\[K\s*|\n[m[K|"
}

function findex() {
    local curpwd=$(pwd)
    if [ $# -lt 2 ]; then
        echo "wrong argument"
        return ;
    fi
    if [[ "$curpwd" != "/" ]]; then
        curpwd="${curpwd}/"
    fi
    keyword="${@[$#]}"
    # local ext="\($1"
    # fd - no \ char
    local ext="($1"

    local exts=()
    for _ext in "$@"; do
        exts+=("$_ext")
    done
    unset "exts[${#exts[@]}]"
    exts=("${exts[@]:1}")

    # local ext="\(c\|cpp\|h\|y\|l\|py\)"
    for (( i=1; i<${#exts[@]}; i++ )); do
        # ext+="\|${exts[$i]}"
        ext+="|${exts[$i]}"
    done
    unset exts
    # ext+="\)$"
    ext+=")$"

    # find . -regex ".*\.$ext" -type f -exec grep -Hn --color=always "$keyword" {} \; |
    fd --regex ".*\.$ext" --type file --color=never --follow --hidden --no-ignore -X grep -lI . |
    xargs -d '\n' -I{} grep -Hn --color=always "$keyword" {} |
    sed -e "s/\:\[m\[K\s*/ |[m[K /2"
}


function findexa() {
    local curpwd=$(pwd)
    if [ $# -lt 2 ]; then
        echo "wrong argument"
        return ;
    fi
    if [[ "$curpwd" != "/" ]]; then
        curpwd="${curpwd}/"
    fi
    keyword="${@[$#]}"
    # local ext="\($1"
    # fd - no \ char
    local ext="($1"

    local exts=()
    for _ext in "$@"; do
        exts+=("$_ext")
    done
    unset "exts[${#exts[@]}]"
    exts=("${exts[@]:1}")

    # local ext="\(c\|cpp\|h\|y\|l\|py\)"
    for (( i=1; i<${#exts[@]}; i++ )); do
        # ext+="\|${exts[$i]}"
        ext+="|${exts[$i]}"
    done
    unset exts
    # ext+="\)$"
    ext+=")$"

    # find . -regex ".*\.$ext" -type f -exec grep -Hn --color=always "$keyword" {} \; |
    fd --regex ".*\.$ext" --type file --color=never --follow --hidden --no-ignore -X grep -lI . |
    xargs -d '\n' -I{} grep -Hn --color=always "$keyword" {} |

    sed -e "s|^|${curpwd}|1" -e "s|\:\[m\[K\s*|[m[K\n|2"
}

function findall() { find . -name "*" -type f -exec grep -Hn --color "$@" {} \; ; }
function svndiff() {
    local SVN_REV=0
    local AGO_REV=0
    # if [[ $@ =~ "-" ]]; then
    if grep -q "-" <<< "$@"; then
        SVN_REV=`svn info | grep Revision | awk -F ': ' ' { print $2 } '`
        local REV_MINUS=`echo $@ | sed -e 's/\-//g'`
        SVN_REV=`expr \( ${SVN_REV} \- ${REV_MINUS} + 1 \)`
        AGO_REV=`expr \( ${SVN_REV} \- 1 \)`
        svn log -r $SVN_REV
    else
        SVN_REV=`echo $@ | cut -d ":" -f2 -s`
        AGO_REV=0
        if [[ $SVN_REV = "" ]]; then
            SVN_REV=$@
            AGO_REV=`expr \( ${SVN_REV} \- 1 \)`
            svn log -r $SVN_REV;
        else
            AGO_REV=`echo $@ | cut -d ":" -f1 -s`
            AGO_REV=`expr \( ${AGO_REV} \- 1 \)`
        fi
    fi
    svn diff -r$AGO_REV:$SVN_REV --summarize | sort;
}

# Í¥ÄÍ≥ÑÍ∞Ä ÏóÜÎäî Îëê Î∏åÎûúÏπòÎ•º Î®∏ÏßÄÌï† Îïå ÏÇ¨Ïö©
# gitapplymacro "abcdefab..12345678" "main"
function gitapplymacro()
{
    commit_between="$1"
    apply_branch="$2"
    git_diff_path="/tmp/gitapplymacro.diff"
    rm -f "$git_diff_path"

    # diff beetween a and b
    git diff ${commit_between} > ${git_diff_path}

    # checkout apply branch
    git checkout ${apply_branch}

    # apply diff
    git apply --reject ${git_diff_path}

    echo "\n"
    echo "check /tmp/gitapplymacro.diff last content"

    echo "\n\n" >> ${git_diff_path}
    echo "========== reject file list ==========\n" >> ${git_diff_path}
    # find merge conflict file
    find . -name "*.rej" -type f >> ${git_diff_path}
    echo "" >> ${git_diff_path}

}


# gitdiff <option> <commit>
# gitdiff --name-only 12345678
# gitdiff --name-only 12345678..abcdefab
function gitdiff() {
    if [ $# -eq 0 ]; then
        git diff
        echo "================================================================"
        git diff --cached
        return 0
    fi

    # --name-only
    local opts=( )
    local commit="$@"
    if [ $# -ge 2 ]; then
        local array=( ${@} )
        local opts=( $(echo "${array[@]:0:${#array[@]}-1}") )
        commit=${@[-1]}
    fi

    if [ -z "$commit" ]; then
        echo "commit argument is empty"
        return 1
    fi

    # commits=$(echo "$commit" | tr ' ' '\n')
    commits=$(echo "$commit" | sed 's/\.\./\n/')
    commit_wcl=$(echo "$commits" | wc -l)

    local head_commit=""
    local tail_commit=""

    if [ $commit_wcl -eq 1 ]; then
        local logs=$(git log --graph --pretty='%Cred%h%Creset - %s %Cgreen(%ad)%C(auto)%d%Creset %C(bold blue)<%an>%Creset' --date=short -2 "$commit" )
        commits=$(echo "$logs" | awk -F ' ' '{ print $2 }')
        head_commit=$(echo "$commits" | head -n 1)
        tail_commit=$(echo "$commits" | tail -n 1)
    elif [ $commit_wcl -eq 2 ]; then
        # gitdiff "aaa..bbb"
        head_commit=$(echo "$commits" | tail -n 1) # bbb
        tail_commit=$(echo "$commits" | head -n 1) # aaa
    else
        echo "wrong diff hash argument (only 1 or 2)"
        return 1
    fi

    if [ -z "$head_commit" ] || [ -z "$tail_commit" ]; then
        echo "diff failed"
        return 1
    fi

    echo "diff $tail_commit -> $head_commit (diff : $(git rev-list --count ${tail_commit}..${head_commit}))"
    echo "\n"
    git diff ${opts[@]} "${tail_commit}..${head_commit}"
}

# echo $SSH_CONNECTION


function vsdiff() { svn diff $@ | vi -; }

function sdfile() {
    # svn diff | grep -E "\-\-\-\s.*(\(revision\s.*\)|\(nonexistent\))";
    svn status | grep "^A" --color=never;
    svn status | grep "^D" --color=never;
    svn status | grep "^M" --color=never;
}

function svnconflict() {
    if [ "$#" -ne 1 ]; then
        echo "wrong argument"
    fi
    svn remove --force "$@"
    svn resolve --accept=working "$@"
}

alias cc='clear'

function rmvimtmp() {
    find . -name ".*.sw*" -type f -exec rm -rf {} \;
    find . -name ".sw*" -type f -exec rm -rf {} \;
}

alias sendhttp='~/req.sh'

#memcheck
#ps -eo user,pid,ppid,rss,size,vsize,pmem,pcpu,time,comm --sort -rss | egrep "USER|health_check"
#ps -aeo user,pid,ppid,rss,size,vsize,pmem,pcpu,time,comm --sort -rss | egrep "USER|health_check"
#top -d 1 | egrep "PID|health_check"


# alias cme='fualias() { myname=`echo "$USER"`; sudo chown -R $myname:$myname $@ ; }; fuinit'
alias cme='fualias() { myname=`whoami`; sudo chown -R $myname $@ ;  }; fuinit'

function killvscode() {
    echo "touch kill_vsc_tmp_script.sh"
    if [ -f ./kill_vsc_tmp_script.sh ]; then
        rm -f ./kill_vsc_tmp_script.sh
    fi
    touch kill_vsc_tmp_script.sh
    chmod 755 kill_vsc_tmp_script.sh
    echo "make command"
    cat << EOF > ./kill_vsc_tmp_script.sh
#!/bin/bash

echo "before kill vscode process"
ps -aef | grep vscode

pkill -f vscode
pkill -f vscode
pkill -f vscode
pkill -f vscode
pkill -f vscode

sleep 1

while true
do
	ps_vscode=\$(ps -ef | grep "vscode" | grep -v ".*\sgrep\s.*vscode.*" | awk -F ' ' '{ print $2 }' | head -n 1)
	if [ -z "\$ps_vscode" ]; then
		break
	fi
	kill -9 \$ps_vscode
done

echo "after kill vscode process"
ps -aef | grep vscode

if [ "\$1" = "1" ]; then
	rm -rf ./kill_vsc_tmp_script.sh
else
	sleep 2
	nohup /bin/bash ./kill_vsc_tmp_script.sh 1 1>/dev/null 2>&1 &
fi

EOF
    return

    echo "execute this file"
    nohup /bin/bash ./kill_vsc_tmp_script.sh 1>/dev/null 2>&1 &
}

# markdown remove unuse image
function rmdimg() {
    # validation check
    if [ $# -eq 0 ] || [ $# -gt 2 ]; then
        echo "wrong argument"
        return
    fi
    local fullpath="$1"
    local filename=$(basename "$fullpath")
    local curpwd=$(pwd)
    local filepath=$(dirname $(readlink -e "$fullpath"))
    builtin cd "$filepath" > /dev/null 2>&1
    local imgdir="mdresources/dir_${filename}_img"
    local imgrealpath=""
    if [ $# -eq 1 ]; then
        imgrealpath=./$imgdir
    else
        imgrealpath=$2/$imgdir
    fi

    if [[ ! -f $filename ]]; then
        echo "file not exist"
        builtin cd "$curpwd" > /dev/null 2>&1
        return
    fi
    if [ ! -d $imgrealpath ]; then
        echo "img dir not exist"
        builtin cd "$curpwd" > /dev/null 2>&1
        return
    fi

    # get file list in imgdir
    # local imgfiles=$(ls $imgrealpath/*.{png,jpg,gif,jpeg,webp})
    local imgfiles=$(ls $imgrealpath)
    filearray=(`echo $imgfiles | tr " " "\n"`)
    # echo "${filearray[@]}"

    # parse img path
    # ![] () remove
    # content=$(grep -E "\!.*\]\(.*$imgdir/img_[^\/]*\)" $filename 2>/dev/null)
    content=$(grep -E "!.*\]\(.*$imgdir/img_[^\/]*\)" $filename)
    content=$(echo "$content" | sed "s/\![^!]*](//g")
    # <img src= > remove
    content2=$(grep -E "<img src=\".*$imgdir/img_[^\/]*\"" $filename 2>/dev/null)
    content2=$(echo "$content2" | sed "s/<img[^\<]*src=\"//g")
    content2=$(echo "$content2" | sed "s/\"[^\>]*>/|/g")
    content=`echo "$content"; echo "$content2"`

    for imgfile in "${filearray[@]}"
    do
        if grep -q "$imgfile" <<<"$content"; then
            echo "exist : $imgfile"
            filearray=( ${filearray[@]/$imgfile} )
        fi
    done

    local rm_index=0
    for imgfile in "${filearray[@]}"
    do
        if [[ "$imgfile" != "" ]]; then
            rm -f $imgrealpath/$imgfile
            rm_index=$(expr $rm_index + 1)
        fi
    done

    if test -n "$(find "$imgrealpath" -maxdepth 0 -type d -empty)" ; then
        echo "directory empty, remove it ($imgrealpath)"
        rmdir $imgrealpath
    fi

    echo "remove ${rm_index} files."
    builtin cd "$curpwd" > /dev/null 2>&1
}

function killdbgprocess() {
    echo "health check process"
    ps -aef | grep health_check
    echo "info_optimizer process"
    ps -aef | grep info_optimizer
    echo ""
    echo "kill health_check"
    pkill -f health_check
    pkill -f health_check
    pkill -f health_check
    echo "kill info_optimizer"
    pkill -f info_optimizer
    pkill -f info_optimizer
    pkill -f info_optimizer
    echo ""
    echo "health check process"
    ps -aef | grep health_check
    echo "info_optimizer process"
    ps -aef | grep info_optimizer
    echo ""
}

AGO_SFTP_DEBUG_PROCESS=""
function gdbs() {
    [[ "$(pidof gdbserver)" != "" ]] && pkill -f gdbserver
    if [[ "$@" != "" ]]; then
        if [[ "$@" = "httpgw" ]]; then
            . ../.vscode/debugger.sh httpgw 0
            # source ../.vscode/debugger.sh httpgw 0
        fi
        gdbserver :9091 ./"$@" &
        AGO_SFTP_DEBUG_PROCESS="$@"
    else
        if [ "$AGO_SFTP_DEBUG_PROCESS" != "" ]; then
            if [[ "$AGO_SFTP_DEBUG_PROCESS" = "httpgw" ]]; then
                . ../.vscode/debugger.sh httpgw 0
                # source ../.vscode/debugger.sh httpgw 0
            fi
            gdbserver :9091 ./"$AGO_SFTP_DEBUG_PROCESS" &
        else
            echo "no argument"
        fi
    fi
}
alias kd='pkill -f gdbserver'


function cpdown() {
    cp -r $@ ~/download/
}

alias colorpreview='for i in {0..255}; do print -Pn ‚Äú%K{$i} %k%F{$i}${(l:3::0:)i}%f ‚Äú ${${(M)$((i%6)):#3}:+$‚Äô\n‚Äô}; done'

alias sshclear='pkill -f "sshd:.*$USER.*\\@"'
alias sshclearall='pkill -f "sshd:.*\\@"'

function pytest() {
    pytest $@;

    if [ -d __pycache__ ]; then
        rm -rf __pycache__/;
    fi

    if [ -d .pytest_cache ]; then
        rm -rf .pytest_cache/;
    fi
}

function splitlog() {
    logpath=""
    split_name=""
    line=100000
    if [ "$(command -v split)" = "" ]; then
        echo "split command not exist"
        return
    fi

    if [ $# -eq 0 ] || [ $# -gt 3 ];then
        echo "wrong argument"
        return
    fi

    if [ $# -eq 1 ]; then
        logpath="$1"
        split_name=$(basename "$logpath")
    elif [ $# -eq 2 ]; then
        line=$1
        logpath="$2"
        split_name=$(basename "$logpath")
    elif [ $# -eq 3 ]; then
        line=$1
        logpath="$2"
        split_name="$3"
    fi
    if [ ! -f "$logpath" ]; then
        echo "file not exist"
        return
    fi

    if [ -d "spdir_${split_name}" ]; then
        echo "already split content exist"
        return
    fi
    mkdir "spdir_${split_name}"
    split -l $line -d --additional-suffix=.log "$logpath" "spdir_${split_name}/${split_name}_"
}


# wiki alias =============================

alias dotfiles='cd $HOME/.dotfiles'
alias jtodo='di $HOME/jdh9232.github.io/wiki/jtodo.md'
function gowiki() { cd ~/jdh9232.github.io/wiki/$@; }
function gomantis() { cd ~/jdh9232.github.io/wiki/issue/issue_note/mantis/$@; }
# alias wifind='fualias() { find ~/jdh9232.github.io/wiki/ -name "*.md" -type f -exec grep --color=always -Hn $@ {} \; | sed -e "p" -e "s/:/ | /2" | sed -n "2~2p" }; fuinit'
function wifind() {
    local blog_dir=~/jdh9232.github.io/wiki/
    if [ ! -d $blog_dir ]; then
        echo "no blog dir"
        return
    fi
    builtin cd $blog_dir;
    grep --color=always -rnIH --include="*.md" $@ ./ | sed -e "p" -e "s/:/ | /2" | sed -n "2~2p"
    builtin cd - > /dev/null ;
}

function wnfind() {
    local blog_dir=~/jdh9232.github.io/wiki/
    test -d $blog_dir && find $blog_dir -type f -name "*.md" | grep "$@"
}





# docker alias ==============================
# sh - docker - origin
function docbash() {
    if [ $# -eq 1 ]; then
        homedir=$(docker exec -u 0 "$1" env | grep "^HOME=" | awk -F 'HOME=' '{print $2}')
        if [[ "$homedir" = "" ]]; then
            homedir="/"
        fi
        docker exec -u 0 -w $homedir -it "$1" bash
    elif [ $# -eq 2 ]; then
        homedir=$(docker exec -u 0 "$1" env | grep "^HOME=" | awk -F 'HOME=' '{print $2}')
        if [[ "$homedir" = "" ]]; then
            homedir="/"
        fi
        docker exec -u $2 -w $homedir -it "$1" bash
    else
        echo "wrong argument"
        return
    fi
}

# sh - docker
function docsh() {
    if [ $# -eq 1 ]; then
        homedir=$(docker exec -u 0 "$1" env | grep "^HOME=" | awk -F 'HOME=' '{print $2}')
        if [[ "$homedir" = "" ]]; then
            homedir="/"
        fi
        docker exec -u 0 -w $homedir -it "$1" zsh
    elif [ $# -eq 2 ]; then
        homedir=$(docker exec -u $2 "$1" env | grep "^HOME=" | awk -F 'HOME=' '{print $2}')
        if [[ "$homedir" = "" ]]; then
            homedir="/"
        fi
        docker exec -u $2 -w $homedir -it "$1" zsh
    else
        echo "wrong argument"
        return
    fi
}





# git alias ==============================

if [ -n "$(locale -a 2>/dev/null | grep 'en_US.UTF-8')" ]; then
    alias git="LANG=en_US.UTF-8 git"
elif [ -n "$(locale -a 2>/dev/null | grep 'en_US.utf8')" ]; then
    alias git="LANG=en_US.utf8 git"
fi

alias delspace="sed -i 's/\s\+$//g'"
alias delspaceall="grep -rlI . | xargs -d '\n' -I{} sed -i 's/\s\+$//g' {}"
# Î¨∏Ïû• Îí§ Í≥µÎ∞± Ï†úÍ±∞
# xargs
# grep -rlI . | xargs -d '\n' -I{} sed -i 's/\s\+$//g' {}
# find
# find ./ -xdev -type f -exec grep -rlI . {} \; -exec sed -i 's/\s\+$//g' {} \; > /dev/null

# git alias
if [ ! -f ~/.gitconfig ]; then
    git config --global alias.co checkout
    git config --global alias.bb "\!$HOME/.dotfiles/script/better_branch.sh"
    git config --global alias.br branch
    git config --global alias.ci commit
    git config --global alias.st status
    git config --global alias.last 'log -1 HEAD'

    # Git Ìé∏Ïßë ÏóêÎîîÌÑ∞ Î≥ÄÍ≤Ω
    git config --global core.editor "vim"
    # Git ÏõêÍ≤© Ï†ÄÏû•ÏÜåÏóêÏÑú ÏÇ≠Ï†úÎêú branchÎ•º Î°úÏª¨ Ï†ÄÏû•ÏÜåÏóêÏÑú ÏûêÎèôÏúºÎ°ú ÏßÄÏö∞Í∏∞

    git config --global fetch.prune true
    git config --global push.default current
    git config --global pull.rebase true
    git config --global rerere.enabled true
    git config --global column.ui never
    git config --global branch.sort -committerdate

    # signed commit
    # git config gpg.format ssh
    # git config user.signingkey ~/.ssh/key.pub
    # git commit -S
    # git push --signed

    # git commit-graph write
    git config --global fetch.writeCommitGraph true

    # git config -global core.untrackedcache true
    # git config -global core.fsmonitor true
    # git config --global --filter=blob:none
    # git config --global --filter=tree:0
    # git sparse-checkout set build base

    # encoding
    git config --global i18n.commitencoding "UTF-8"
    git config --global i18n.logoutputencoding "UTF-8"

    git config --global core.sshCommand "ssh -F $HOME/.ssh/config -i $HOME/.ssh/id_rsa -o UserKnownHostsFile=$HOME/.ssh/known_hosts -o StrictHostKeyChecking=no"

    # diff, merge
    git config --global diff.tool bcompare
    git config --global diff.euckr.textconv "iconv -f euc-kr -t utf-8"
    git config --global merge.tool bcompare
    git config --global difftool.bcompare.cmd "$HOME"/'.bcomp.sh "$LOCAL" "$REMOTE"'
    git config --global difftool.bcompare.trustExitCode true
    git config --global mergetool.bcompare.cmd "$HOME"/'.bcomp.sh "$LOCAL" "$REMOTE" "$BASE" "$MERGED"'
    git config --global mergetool.bcompare.trustExitCode true
    git config --global mergetool.bcompare.keepBackup false
fi


# gb -> git branch
# gba -> git branch -a (git branch --all)
# gco -> git checkout
# gci -> git commit
# gbv -> git branch -vv
# gs, gst ->  git status
# gsti  ->  git stash
# gsb -> git status -sb
# gr -> git remote
# grb -> git rebase
# grev -> git revert
# gsh -> git reset
# grs -> git restore


fuunalias_alias()
{
    local alias_name=$1
    local cmd=$2
    local is_cmd=`alias | grep "\<$alias_name\>="`
    if [[ "$is_cmd" != "" ]]; then
        unalias $alias_name
    fi
    if [[ "$cmd" != "" ]]; then
        alias $alias_name="$cmd"
    fi
}


fuunalias_alias 'gb' 'git branch'
fuunalias_alias 'gba' 'git branch --all'
fuunalias_alias 'gco' 'git checkout'
fuunalias_alias 'gsh' 'git reset'
fuunalias_alias 'grs' 'git restore'
fuunalias_alias 'gci' 'git commit'
fuunalias_alias 'gcf' 'git config'
fuunalias_alias 'gcfl' 'git config --list'
fuunalias_alias 'gs' 'git status'
fuunalias_alias 'gst' 'git status'
fuunalias_alias 'gsti' 'git stash'
# push stash untracked file
fuunalias_alias 'gstiu' 'git stash push -u'
# keep staging file
fuunalias_alias 'gstik' 'git stash push -k'
fuunalias_alias 'gstiku' 'git stash push -k -u'
fuunalias_alias 'gstmp' ''
fuunalias_alias 'gsta' ''
fuunalias_alias 'gstai' ''
fuunalias_alias 'gstc' 'git checkout stash -- .'
fuunalias_alias 'gstclr' 'git stash clear'
fuunalias_alias 'gstl' 'git stash list'
fuunalias_alias 'gstia' 'git stash push -k -u'
fuunalias_alias 'gsm' 'git submodule'
fuunalias_alias 'gbv' 'git branch -vv'
fuunalias_alias 'gu' 'git push'
fuunalias_alias 'gp' 'git pull'
# merge no commit no ff (squash - no commit)
fuunalias_alias 'gmn' 'git merge --no-commit --no-ff'
fuunalias_alias 'gmns' 'git merge --squash --no-commit'
# fatal: refusing to merge unrelated histories - Í¥ÄÎ†® Í∏∞Î°ùÏù¥ ÏóÜÎäî Îëê Ïù¥ÏßàÏ†ÅÏù∏ ÌîÑÎ°úÏ†ùÌä∏ Î≥ëÌï©
fuunalias_alias 'gmnsah' 'git merge --squash --no-commit --allow-unrelated-histories'
fuunalias_alias 'grevtme' 'git revert --no-edit --no-commit'
fuunalias_alias 'gl' ''
fuunalias_alias 'gsi' ''
fuunalias_alias 'gpf' ''
fuunalias_alias 'gpsh' 'git push'
fuunalias_alias 'gpshfl' 'git push --force-with-lease'
fuunalias_alias 'gpshfc' 'git push --force'
fuunalias_alias 'gcpick' 'git cherry-pick'
fuunalias_alias 'gcpicknci' 'git cherry-pick --no-commit'



function gstai() {
    if [[ "$@" = "" ]]; then
        git stash apply
    else
        git stash apply stash@{$@}
    fi
}
alias gsta='gstai'
function gstac() {
    if [ $# -eq 0 ]; then
        echo "wrong argument"
        return
    fi
    if [ $# -eq 1 ]; then
        git checkout stash@{0} "$1"
        return
    fi

    for arg in "${@:2}"; do
        git checkout stash@{$1} "$arg"
    done

}

# Í∞ÄÏû• ÏµúÍ∑ºÏóê Ï†ÄÏû•Îêú stashÏùò Î≤àÌò∏Îäî 0Î≤àÏù¥Îã§.
function gstmp() {
    if [[ "$@" = "" ]]; then
        git stash push -k -u
    else
        git stash push -k -u $@
    fi
    git stash apply stash@{0}

    echo ""
    echo ""
    echo "stash list"
    git stash list
    echo ""
}

function gl() {
    # git log --graph --pretty='\''%Cred%h%Creset - %s %Cgreen(%ad)%C(auto)%d%Creset %C(bold blue)<%an>%Creset'\'' --date=short $@
    local AGO_LC_ALL="$LC_ALL"
    if [ "$(locale -a 2>/dev/null | grep 'ko_KR.UTF-8')" ]; then
        export LC_ALL=ko_KR.UTF-8
    elif [ "$(locale -a 2>/dev/null | grep 'ko_KR.utf8')" ]; then
        export LC_ALL=ko_KR.utf8
    fi
    git log --graph --pretty='%Cred%h%Creset - %s %Cgreen(%ad)%C(auto)%d%Creset %C(bold blue)<%an>%Creset' --date=short $@
    export LC_ALL="$AGO_LC_ALL"
}

# glr
# glr <option1> <option2>
# glr <option1> <option2> ... <remote name - ex ) origin>
function glr() {
    local remote_branch="$(git rev-parse --abbrev-ref HEAD)"
    if [[ "${remote_branch}" = "HEAD" ]]; then
        echo "failed to get remote branch name"
        exit 1
    fi

    local opts=""
    local remotes=""
    if [ $# -eq 0 ]; then
        remotes="origin"
    else
        remotes="${@:${#}:1}"
        if [[ "${remotes:0:1}" = "-" ]]; then
            opts=( $@ )
            remotes="origin"
        else
            # $@ ÏóêÏÑú Îëê Î≤àÏß∏ Ïù∏ÏûêÎ∂ÄÌÑ∞ ÎÅùÍπåÏßÄ Î∞∞Ïó¥Î°ú Ï†ÄÏû•
            # opts=(${@:2:${#}-1})
            # $@ ÏóêÏÑú Ï≤´ Î≤àÏß∏ Ïù∏ÏûêÎ∂ÄÌÑ∞ ÎÅù-1 ÍπåÏßÄ Î∞∞Ïó¥Î°ú Ï†ÄÏû•
            opts=(${@:1:${#}-1})
        fi
    fi
    local AGO_LC_ALL="$LC_ALL"
    if [ "$(locale -a 2>/dev/null | grep 'ko_KR.UTF-8')" ]; then
        export LC_ALL=ko_KR.UTF-8
    elif [ "$(locale -a 2>/dev/null | grep 'ko_KR.utf8')" ]; then
        export LC_ALL=ko_KR.utf8
    fi
    # git log --graph --pretty='\''%Cred%h%Creset - %s %Cgreen(%ad)%C(auto)%d%Creset %C(bold blue)<%an>%Creset'\'' --date=short $@
    git log --graph --pretty='%Cred%h%Creset - %s %Cgreen(%ad)%C(auto)%d%Creset %C(bold blue)<%an>%Creset' --date=short $opts "remotes/${remotes}/${remote_branch}"
    export LC_ALL="$AGO_LC_ALL"
}



function gld() {
    local AGO_LC_ALL="$LC_ALL"
    if [ "$(locale -a 2>/dev/null | grep 'ko_KR.UTF-8')" ]; then
        export LC_ALL=ko_KR.UTF-8
    elif [ "$(locale -a 2>/dev/null | grep 'ko_KR.utf8')" ]; then
        export LC_ALL=ko_KR.utf8
    fi

    if [ $# -eq 0 ]; then
        git log --graph --pretty='%Cred%h%Creset - %s %Cgreen(%ad)%C(auto)%d%Creset %C(bold blue)<%an>%Creset' --date=short ./
    else
        if [[ "$1" = "/" ]]; then
            git log --graph --pretty='%Cred%h%Creset - %s %Cgreen(%ad)%C(auto)%d%Creset %C(bold blue)<%an>%Creset' --date=short ${@:2}
        elif [[ "${1:0:1}" = "-" ]]; then
            git log --graph --pretty='%Cred%h%Creset - %s %Cgreen(%ad)%C(auto)%d%Creset %C(bold blue)<%an>%Creset' --date=short $@ ./
        else
            git log --graph --pretty='%Cred%h%Creset - %s %Cgreen(%ad)%C(auto)%d%Creset %C(bold blue)<%an>%Creset' --date=short $@
        fi
    fi

    export LC_ALL="$AGO_LC_ALL"
}

alias gitsync='git remote update origin --prune'
function gitsvnrev() {
    if [[ "$@" = "" ]]; then
        return
    fi

    local revinf="$@"
    if [[ "${revinf:0:1}" = "r" ]]; then
        for branch in $(git for-each-ref --format='%(refname)' refs/heads/); do
            local inform=$(git svn find-rev $@ $branch)
            if [[ "$inform" = "" ]]; then
                continue
            fi
            echo "branch (${branch}) : ${inform}"
        done
    else
        git svn find-rev $@
    fi
}

# [svn-remote "v5.0"]
#     url = svn://1.1.1.1/test/v5.0
#     fetch = :refs/remotes/origin/develop
# [svn-remote "v5.0.2"]
#     url = svn://1.1.1.1/test/v5.0.2_2
#     fetch = :refs/remotes/origin/main

function gitsvnrevb() {
    if [ $# -le 1 ]; then
        git svn find-rev $@ $(git rev-parse --abbrev-ref HEAD)
    elif [ $# -eq 2 ]; then
        git svn find-rev $1 $2
    else
        git svn find-rev $(git log remotes/origin/$@ --max-count 1 --pretty=format:%H)
    fi
}

# git size
# git Ïª§Î∞ã ÏÇ¨Ïù¥Ï¶à Í≥ÑÏÇ∞
# git diff --cached --numstat  | awk '{ plus+=$1; minus+=$2; } END { sum = plus + minus; printf sum; }'
function gsi() {
    # https://github.com/baekdev/git-stat
    # git add -A && git diff --cached --numstat | awk '{
    git diff --cached --numstat | awk '{
        count+=1;
        plus+=$1;
        minus+=$2;
    } END {
        # Color Variables
        BLACKC="\033[30m";REDC="\033[31m";REDB="\033[41m";GREENB="\033[42m";YELLOWB="\033[43m";
        BLUEC="\033[34m";BLUEB="\033[44m";MAGENTB="\033[45m";NORMALB="\033[49m";NORMALC="\033[0m";

        # Range of change size
        rangeTo["XS"] = 10;
        rangeTo["S"] = 50;
        rangeTo["M"] = 100;
        rangeTo["L"] = 250;

        printf ">>> Git Local Changes Stat\n";

        if (plus <= 0 && minus <= 0) {
            printf "‚Ä∫>> Any no changes \n";
            exit 0;
        }

        sum = plus + minus;
        size = "XS";
        color = GREENB;

        if ( sum < rangeTo["XS"] ) {
            size = "XS"
            color = GREENB;
        } else if ( sum < rangeTo["S"] ) {
            size = "S";
            color = BLUEB;
        } else if( sum < rangeTo["M"] ) {
            size = "M";
            color = YELLOWB;
        } else if( sum < rangeTo["L"] ) {
            size = "L";
            color = MAGENTB;
        } else {
            size = "XL";
            color = REDB;
        }
        printf ">>> " count " files," REDC plus " insertions(+), " BLUEC minus " deletions(-)" NORMALB NORMALC "\n";
        printf ">>> " color BLACKC " Your commit size is " size ". " NORMALB NORMALC "\n";
    }'
}

alias gital='alias | grep "^g.*git"'

alias gdd='git diff | grep "\<printf\>"'

# gitstatsd - git stats debug
# zsh -dfxic 'GITSTATUS_ENABLE_LOGGING=1 && source ~/.zsh/.oh-my-zsh/custom/themes/powerlevel10k/gitstatus/gitstatus.plugin.zsh && gitstatus_start MY && gitstatus_query MY && cat $GITSTATUS_DAEMON_LOG_M'

# git svn fetch error (untracked file)
alias gitup='git update-index --assume-unchanged'
alias gitupa='git update-index --really-refresh'
function gitupall() {
git status -s | awk -F ' ' '{print $2}' | xargs git update-index --assume-unchanged
git update-index --really-refresh
# git status -s | awk -F ' ' '{print $2}' | xargs git update-index --really-refresh
}

function gitsvnfetchall() {
    branches=( $(git config --local --list | grep "^svn-remote\..*\.url=.*" | awk -F '.' '{ print $2 }' | sort -u) )
    for branch in "${branches[@]}"; do
        echo "fetch branch : \"$branch\""
        git svn fetch "$branch"
    done

    echo ""
    echo "done"
    echo ""
    echo "you can execute the command"
    echo "git svn rebase"
}

function gsvnup() {
    if [ "$(git config --list | grep svn)" = "" ]; then
        return
    fi
    rev="$@"
    rev_hash=$(git svn find-rev "$rev" $(git rev-parse --abbrev-ref HEAD))
    git checkout "$rev_hash"
}

# Î™®Îì† Î≥ÄÍ≤ΩÏÇ¨Ìï≠ pull
function pullall() {
    local branch=origin
    if [ $# -eq 1 ]; then
        branch=$1
    fi
    git branch -r | grep -v "\->" | while read remote; do git branch --track "${remote#${branch}/}" "$remote"; done
    git branch -r | grep -v "\->" | while read remote; do git branch --set-upstream-to="$remote" "${remote#${branch}/}"; done
    git fetch --all
    git pull --all
}
alias missmerge='grep -rnI "\s*<<<<<<< "'

function gconflictundo()
{
    con_path=$@
    if [[ $con_path = "" ]]; then
        con_path=.
    fi
    # git status -s $con_path | grep "^AA " | awk -F '\''AA '\'' '\'' { print $2 } '\'' | xargs -I {} echo {}
    git status -s $con_path | grep "^AA " | awk -F 'AA ' ' { print $2 } ' | xargs -I {} git checkout --merge {}
}

# git reset conflict
function grsco()
{
    merge_list=$(gst --short | grep UU | sed 's/^UU //')
    echo "$merge_list"
    echo "$merge_list" | xargs -I {} git reset {}
}


function greverts()
{
    revert_list=( "${@}" )
    for revert_hash in "${revert_list[@]}"; do
        git revert --no-edit --no-commit "$revert_hash"
    done
}

# git status -s . | grep "^AA " | awk -F 'AA ' ' { print $2 } ' | xargs -I {} git checkout --merge {}

# git note =====================================================================

# git commit message ÏàòÏ†ï
# git commit --amend -m "message"

# git orphan branch Î®∏ÏßÄ
# git merge --allow-unrelated-histories -X theirs a(merge apply) b (merge target)
# git merge --allow-unrelated-histories --squash feature/waf50 remotes/svn/git-svn
# ->  feature/waf50Ïóê remotes/svn/git-svn Î≥ÄÍ≤ΩÏÇ¨Ìï≠Ïù¥ Ï†ÅÏö©Îê® (squashÎ•º Ï†ÅÏö©ÌñàÍ∏∞ ÎïåÎ¨∏Ïóê Ïª§Î∞ã Î°úÍ∑∏Îäî ÌïòÎÇòÎ°ú Ìï©Ï≥êÏßê)

# git remoteÏóêÏÑú ÏÇ≠Ï†úÎêú Î∏åÎûúÏπò ÎèôÍ∏∞ÌôîÌïòÍ∏∞
# git remote prune origin

# git merge (origin branch) (target branch)
# git co --ours dir/* -> origin branch Î≥ÄÍ≤ΩÏÇ¨Ìï≠ Ï†ÅÏö© (ÌòÑÏû¨ Î∏åÎûúÏπò ÎÇ¥Ïö© Ï†ÅÏö©) (gco -2 dir/*)
# git co --theirs dir/* -> target branch Î≥ÄÍ≤ΩÏÇ¨Ìï≠ Ï†ÅÏö© (Î∏åÎûúÏπò Î®∏ÏßÄÎÇ¥Ïö© Ï†ÅÏö©) (gco -3 dir/*)
# git co --merge dir/* -> Ï∂©ÎèåÎïåÎ°ú undo (gco -m dir/*)
# Ï∂©ÎèåÎïåÎ°ú undo Ïãú ÏóêÎü¨Í∞Ä ÎÇòÎ©¥ (ÌòÑÏû¨ Í≤ΩÎ°ú)
# git status -s . | grep "^AA " | awk -F 'AA ' ' { print $2 } ' | xargs -I {} git checkout --merge {}

# git-svn
# git svn init svn://1.1.1.1/REPO/v5.0 --prefix=svn/
# git svn fetch
# git checkout -b git-svn remotes/svn/git-svn
# git push origin git-svn

# git-svn fetch and dcommit
# git svn fetch v5.0
# git checkout waf50
# git merge --hard origin/waf50   or   git reset --merge orogin/waf50   or   git rebase remotes/origin/waf50
# git svn dcommit --username username

# ==============================================================================

alias dateunix='date "+%s"'

alias „Ö£„Ö£='ls -lhF'
alias „Ö£„Ö£„ÖÅ='ls -alhF'
alias „Öä„Öá='cd'
alias ÌçÑ='vim'
alias „Ñ∑ÌÑã='exit'
alias Ïïº='di'
alias dk='di'
alias ÏïÑ='di'
alias „Ñ¥Ìó∑='sgpt'
alias sgptc='sgpt --code'
alias „Ñ¥Ìó∑„Öä='sgpt --code'

# td set eth1
# td 80
# td 80 tcp -w packet.pcap
function td()
{
    if [ -z "$td_iface" ]; then
        echo "not 'td_iface' set"
        td_iface="eth0"
    fi

    if [ $# -eq 0 ]; then
        echo "wrong argument tcpdump"
        echo "current show iface : '$td_iface'"
        return 1
    elif [ $# -eq 1 ]; then
        tcpdump -nn -vv -i "$td_iface" tcp port $@
    elif [ $# -eq 2 ] && [[ "$1" = "set" ]]; then
        echo "set td_iface=$2"
        td_iface="$2"
        return 0
    else
        # 5Î¨∏Ïûê Îí§ Î¨∏ÏûêÎ•º Ï∂úÎ†• (ex. "qwertyasdf" -> "yasdf")
        # local opt=( $(echo "$@" | cut -c5- ) )
        # ' ' Î¨∏ÏûêÎ•º Í∏∞Ï§ÄÏúºÎ°ú 3Î≤àÏß∏Î∂ÄÌÑ∞ Ï∂úÎ†• ("a b c d" -> "c d")
        # local opt=$(echo "$@" | cut -d ' ' -f 3-)
        # 3Î≤àÏß∏Î∂ÄÌÑ∞ Ï∂úÎ†• : bashÎÇò zshÎÇò ÎèôÏùº
        for arg in "${@:3}"; do
            opt+=("$arg")
        done
        tcpdump -nn -vv -i "$td_iface" $2 port $1 ${opt[@]}
    fi
}

function idump()
{
    if [ ! -f $HOME/inetdump ]; then
        echo "cannot find $HOME/inetdump"
        return
    fi
    $HOME/inetdump
}

# alias
[ -f $HOME/.alias_waf ] && source ~/.alias_waf


return 0

