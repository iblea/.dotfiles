fualias() { echo -n ""; }

fuinit() {
fualias $@ ; unset -f fualias; fualias () { echo -n ""; }
}

function function_exist_check() {
    if (declare -f -F "$@" > /dev/null); then
        return 0
    else
        return 1
    fi
}

# function cd() {
#     builtin cd "$@"
#     if [ $? -ne 0 ]; then
#         return
#     fi
#     ls --color=auto -AF
#     echo ""
#     pwd
# }

# zsh 아니면 cd 명령어는 기존대로 처리
if ( grep -q "/zsh" <<< "$SHELL" ); then

function cdb() {
    builtin cd "$@"
    # ls --color=auto -AF
    # echo ""
    pwd
}

if [ -z "$_ZO_DATA_DIR" ]; then
    source $HOME/.dotfiles/script/cdscript.sh
fi
fi

function fg() {
    if [ $# -eq 1 ] && [[ "$@" = "-" ]]; then
        builtin fg %-
    else
        builtin fg %"$@"
    fi
}

if [ -n "$(command -v nvim)" ]; then
    alias nvi='nvim'
    alias vi='nvim'
    alias vim='nvim'
    alias ovim="$(/bin/bash -c 'which vim')"
fi
alias vit="vi -c ':term'"



# enable color support of ls and also add handy aliases
if [ -f $HOME/.dotfiles/.shell_color.sh ]; then
    . $HOME/.dotfiles/.shell_color.sh
elif [ -f $HOME/.shell_color.sh ]; then
    . $HOME/.shell_color.sh
fi

alias grepo="grep --color=auto -rnIH"
alias grepi="grep --color=auto -rnIHP"
alias grepapi="grep --color=auto --exclude-dir=hmapi -rnIHP"
# alias grepf="grep --color=auto -rnIHF"
alias grepq="grep --color=auto -rnIHF"


# ssh
if [ -f $HOME/.ssh/config ]; then
    alias ssh='ssh -F $HOME/.ssh/config -i $HOME/.ssh/id_rsa -o UserKnownHostsFile=$HOME/.ssh/known_hosts'
    alias scp='scp -F $HOME/.ssh/config -i $HOME/.ssh/id_rsa -o UserKnownHostsFile=$HOME/.ssh/known_hosts'
    alias sshinit='ssh-keygen -f $HOME/.ssh/known_hosts -R '
    alias ibrew="arch -x86_64 /usr/local/bin/brew"
fi

# some more ls aliases

# alias ll='ls -1shF'
# alias lla='ls -1ashF'
unalias ll
function ll()
{
    lsoutput=$( ls -lhF --color=always $@ )
    size_col_width=15

    echo "$lsoutput" | head -n 1
    echo "$lsoutput" | tail -n +2 | awk '{
        printf "%-7s ", $5
        for(i=9;i<=NF;i++) printf "%s ", $i;
        print ""
    }'
}

function lla()
{
    lsoutput=$( ls -alhF --color=always $@ )
    size_col_width=15

    echo "$lsoutput" | head -n 1
    echo "$lsoutput" | tail -n +2 | awk '{
        printf "%-7s ", $5
        for(i=9;i<=NF;i++) printf "%s ", $i;
        print ""
    }'
}

# alias ll='ls -lhF'
# alias lla='ls -alhF'
alias l='ls -hCF'
alias la='ls -ahCF'
# alias l='ls -hCF -w 160'
# alias la='ls -ahCF -w 160'
alias le='ls -lhF'
alias lw='ls -shCF -w 180'
alias lea='ls -alhF'
alias af='ls -shCF -w 180'
alias sf='ls -shF1'
# alias f='ls -hF'
alias f='ls -1shF'
# alias fa='ls -shaCF -w 60'
alias fa='ls -1shaF'
alias fs='ls -1shF'
alias j='ls -shCF'
alias ja='ls -shaCF'
# alias j='ls -shCF -w 180'
# alias ja='ls -shaCF-w 180'
# alias ja='ls -shaCF'
alias jj='ls -1shF'
alias jja='ls -1shaF'

alias ef='ls -lhF'
alias fe='ls -alhF'
alias wf='ls -ohF'
alias fe='ls -alhF'
alias kd='ls -shCF -w 60'
# alias l='ls -shCF -w 60'
# alias l='ls -1shF'
alias psa='ps -aef'

function psf() {
    process_name="$@"
    ps -aef | head -n1
    # ps -aef | grep --color=always "$process_name" | grep -v "grep --color.*always.*$process_name"
    if [ $# -eq 0 ]; then
        ps -aef
        return 0
    fi

    IFS='' process_names=( $@ )
    processes="$(ps -aef)"

    for process_name in "${process_names[@]}" ; do
        # bash -c "echo -e \"${processes}\" | grep --color=always \"$process_name\" | grep -v \"grep --color.*always.*$process_name\""
        echo -e "${processes}" | grep -a --color=always "$process_name" | grep -a -v "grep --color.*always.*$process_name"
    done

}

function perft() {
    if [ $# -eq 0 ]; then
        perf top
        return 0
    fi

    IFS='' process_names=( $@ )
    process_str=""
    for process_name in "${process_names[@]}" ; do
        process_str="$process_str,$(pidof "$process_name" | tr ' ' ',')"
    done
    if [ "${process_str:0:1}" = "," ]; then
        process_str="${process_str:1}"
    fi
    # echo "$process_str"
    perf top  --pid=$(echo "$process_str")
    # perf top  --pid=$(pidof "${process_names[@]}" | tr ' ' ',')
}

function topd() {
    process_name="$@"
    if [ $# -eq 0 ]; then
        top -b -n 1
        return 0
    fi

    IFS='' process_names=( $@ )
    processes="$(top -b -n 1)"
    echo "$processes" | head -n 7

    for process_name in "${process_names[@]}" ; do
        echo -e "${processes}" | grep -a --color=always "$process_name" | grep -a -v "grep --color.*always.*$process_name"
    done

}

function psu() {
    process_name="$@"
    ps -aux | head -n1
    # ps -aux | grep --color=always "$process_name" | grep -v "grep --color.*always.*$process_name"
    if [ $# -eq 0 ]; then
        ps -aux
        return 0
    fi

    IFS='' process_names=( $@ )
    processes="$(ps -aux)"

    for process_name in "${process_names[@]}" ; do
        # bash -c "echo -e \"${processes}\" | grep --color=always \"$process_name\" | grep -v \"grep --color.*always.*$process_name\""
        echo -e "${processes}" | grep -a --color=always "$process_name" | grep -a -v "grep --color.*always.*$process_name"
    done

}

function watcha() {
    if [ $# -eq 2 ]; then
        watch --color -n $1 -x bash -c "source ~/.aliases; $2"
    else
        watch --color -n 1 -x bash -c "source ~/.aliases; $@"
    fi
}

alias makef='make -j8'

# add export path
if [ -d $HOME/.dotfiles/.bin/ ]; then
    if ! grep -q "$HOME/.dotfiles/.bin" <<< "$PATH"; then
        export PATH=$HOME/.dotfiles/.bin:$PATH
    fi
fi

if [ -n "$(command -v 'code-insiders')" ]; then
    alias code='code-insiders'
fi

# =======================================================================

# wsl command
if [ -n "$(uname -r | grep 'WSL')" ]; then
    if [ "$(command -v code)" = "" ]; then
        codepath="/mnt/c/jvscode/Code.exe"
        if [ -f $codepath ] && [ ! -f $HOME/.local/bin/code ]; then
            [ ! -d $HOME/.local/bin/ ] && mkdir -p $HOME/.local/bin/
            ln -s $codepath $HOME/.local/bin/code
        fi
        unset codepath
    fi

    # windows + explorer
    function epl() {
        if [[ "$@" = "" ]]; then
            /mnt/c/WINDOWS/explorer.exe .
            return
        fi
        if [ -d "$@" ]; then
            builtin cd "$@"
            /mnt/c/WINDOWS/explorer.exe .
            builtin cd - > /dev/null
            return
        fi
        /mnt/c/WINDOWS/explorer.exe .
    }

    # function code() {
    #     if [[ "$@" = "s" ]]; then
    #         /mnt/c/jvscode/Code.exe ./
    #     else
    #         /mnt/c/jvscode/Code.exe $@
    #     fi
    # }

    function goc() { cd /mnt/c/$@; }
    function god() { cd /mnt/d/$@; }
    function goe() { cd /mnt/e/$@; }
    function govscode() { cd /mnt/c/jvscode/data/user-data/User/$@; }
    function gohome() { cd /mnt/c/Users/ghkd0/$@; }
    function golog() { cd /mnt/e/mylog/$@; }
    function godown() { cd /mnt/c/Users/ghkd0/Downloads/$@; }
    function godesktop() { cd /mnt/c/Users/ghkd0/Desktop/$@; }

    # "/mnt/c/Program\\ Files/Beyond\\ Compare\\ 4/BComp.exe"
    # alias diffb='"/mnt/c/Program Files/Beyond Compare 4/BComp.exe"'
    alias diffb='~/.bcomp.sh'

    alias curla="/mnt/c/Users/ghkd0/Videos/.aaa_testcurl.sh"
    alias curlq="/mnt/c/Users/ghkd0/Videos/.qqq_testcurl.sh"
    alias curls="/mnt/c/Users/ghkd0/Videos/.rrr_testcurl.sh"

    [[ "$TERM_PROGRAM" != "vscode" ]] && (builtin cd $HOME)
# mac command
elif [[ "$(uname -s)" = "Darwin" ]]; then
    # alias code="/Applications/'Visual Studio Code.app'/Contents/Resources/app/bin/code"

    # .bin/code
    # if [ -d "/Applications/Cursor.app" ]; then
    #     alias code="/Applications/Cursor.app/Contents/Resources/app/bin/code"
    # elif [ -d "/Applications/Visual Studio Code.app" ]; then
    #     alias code="/Applications/Visual Studio Code.app/Contents/Resources/app/bin/code"
    # fi
    # export PATH="$PATH:/Applications/Visual Studio Code.app/Contents/Resources/app/bin"
    # alias diffb='~/.bcomp'

    # macos
    if [ -d "/Applications/Hex Fiend.app" ]; then
        alias hxd='open -a /Applications/Hex\ Fiend.app'
        alias hexvi='open -a /Applications/Hex\ Fiend.app'
    fi
    alias diffb='"/Applications/Beyond Compare.app/Contents/MacOS/BComp"'
    alias which="$(/bin/bash -c 'which which' 2>/dev/null)"
    alias ldd="otool -L"


    # vim -> mvim, nvim
    if [ -d "/Applications/MacVim.app/" ]; then
        alias mvi='/Applications/MacVim.app/Contents/bin/vim'
        alias mvim='/Applications/MacVim.app/Contents/bin/mvim'
        alias macvim='/Applications/MacVim.app/Contents/bin/vim'
        # alias vi="/Applications/MacVim.app/Contents/bin/vim"
        # alias vim="/Applications/MacVim.app/Contents/bin/vim"
    fi
    if [ -d "/Applications/goneovim.app" ]; then
        alias gvim='/Applications/goneovim.app/Contents/MacOS/goneovim'
        alias gi='/Applications/goneovim.app/Contents/MacOS/goneovim'
    fi

    # brew install findutils
    if [ -f /opt/homebrew/bin/gxargs ]; then
        alias xargs="/opt/homebrew/bin/gxargs"
    fi

    function godown() { cd $HOME/Downloads/$@; }
    function godoc() { cd $HOME/Documents/$@; }
    function gonote() { cd $HOME/.notepad/$@; }
    alias notecode="code $HOME/.notepad/"
    function gont() { cd $HOME/.notepad/$@; }
    # go google drive
    function gogd() { cd "$HOME/GoogleDrive/$@"; }
    function godrive() { cd "$HOME/GoogleDrive/$@"; }
    function goicloud() { cd "$HOME/Library/Mobile Documents/com~apple~CloudDocs/$@"; }
    function goissue() { cd $HOME/issue/$@; }

    # ppk to pem
    function ppktopem() {
        if [ "$(command -v puttygen)" = "" ]; then
            echo "install putty first"
            echo "brew install putty"
            return
        fi
        filename=$@
        extname="${filename:$(expr ${#filename} - 4)}"
        if [[ "$extname" != ".ppk" ]]; then
            echo "not ppk file"
            return
        fi
        pemname=$(echo "$filename" | sed 's/.ppk$/.pem/')
        puttygen "$filename" -O private-openssh -o "$pemname"
    }

    function pemtoppk() {
        if [ "$(command -v puttygen)" = "" ]; then
            echo "install putty first"
            echo "brew install putty"
            return
        fi
        filename=$@
        puttygen "$filename" -o "${filename}.ppk"
    }

    function ddns_set() {
        ddns_script_path="$HOME/GoogleDrive/develop/settings/ddns_cloudflare.sh"
        if [ ! -x $ddns_script_path ]; then
            echo "$ddns_script_path"
            echo "not found ddns script path"
            return 1
        fi
        "$ddns_script_path" $@
    }
    alias ddnset="ddns_set"

    function ddnsvi() {
        ddns_script_path="$HOME/GoogleDrive/develop/settings/ddns_cloudflare.sh"
        if [ ! -x $ddns_script_path ]; then
            echo "$ddns_script_path"
            echo "not found ddns script path"
            return 1
        fi
        vim "$ddns_script_path"
    }
    alias keyvi="vi \"$HOME/GoogleDrive/keys/keys.txt\""


    alias gosr="cd $HOME/src"
    alias gosrc="cd $HOME/src"
    # cd practice directory
    alias gotest="cd $HOME/src/testsrc"
    alias gocert="cd $HOME/Documents/cert"

    alias curla="$HOME/curltest/.aaa_testcurl.sh"
    alias curls="$HOME/curltest/.sss_testcurl.sh"
    alias curld="$HOME/curltest/.ddd_testcurl.sh"
    alias curlq="$HOME/curltest/.qqq_testcurl.sh"
    alias curle="$HOME/curltest/.eee_testcurl.sh"
    alias curlr="$HOME/curltest/.rrr_testcurl.sh"
    alias curlg="$HOME/curltest/.ggg_testcurl.sh"
    alias curlavi="vim $HOME/curltest/.aaa_testcurl.sh"
    alias curlsvi="vim $HOME/curltest/.sss_testcurl.sh"
    alias curldvi="vim $HOME/curltest/.ddd_testcurl.sh"
    alias curlqvi="vim $HOME/curltest/.qqq_testcurl.sh"
    alias curlevi="vim $HOME/curltest/.eee_testcurl.sh"
    alias curlrvi="vim $HOME/curltest/.rrr_testcurl.sh"
    alias curlgvi="vim $HOME/curltest/.ggg_testcurl.sh"
    alias dockoff="defaults write com.apple.dock autohide-delay -float 1000; killall Dock"
    alias dockon="defaults delete com.apple.dock autohide-delay; killall Dock"

    # explorer
    alias epl="open ."
    alias expl="open ."

    alias gk="/opt/homebrew/bin/gk"

    function aidi() {
        $HOME/.dotfiles/script/aider.sh
    }

    function aidic() {
        rm -f $HOME/.config/aider/history.input.md
    }

    function aidicc() {
        rm -f $HOME/.config/aider/history.chat.md
    }

    function aidica() {
        rm -f $HOME/.config/aider/history.chat.md
        rm -f $HOME/.config/aider/history.input.md
    }


else
    alias diffb='~/.bcomp.sh'
    # .bin/code
    # if [ -n "$(command -v cursor)" ]; then
    #     alias code="cursor"
    # fi
fi

# =======================================================================







# diffdirectory - diffdir
function diffdir()
{
    directory_1="v5.0"
    directory_2="v5.0.2_2"

    file1="$directory_1/$@"
    file2="$directory_2/$@"
    if [ ! -f $file1 ]; then
        echo "$file1 not exist"
        return
    elif [ ! -f $file2 ]; then
        echo "$file2 not exist"
        return
    fi

    diffb "$file1" "$file2"
}

# absolute path
alias abs='readlink -e'
alias rpth='readlink -e'

alias grepno="$HOME/.dotfiles/grepscript/grepno"
alias grepn="$HOME/.dotfiles/grepscript/grepn"
alias grepm="$HOME/.dotfiles/grepscript/grepm"

alias agrepno="$HOME/.dotfiles/grepscript/agrepno"
alias agrepn="$HOME/.dotfiles/grepscript/agrepn"
alias agrepm="$HOME/.dotfiles/grepscript/agrepm"

# 반복문에서 echo 및 sed 시 성능이 너무 떨어짐
# agrepn 단독 사용 시 0.04sec 걸리는 명령어가 grepnz 사용 시 3.5sec 까지 늘어남.
# 따라서 반복문 내에서 echo 와 sed 사용을 최소화
# for line in "${output_array[@]}"; do
#     if [ -z "$line" ]; then
#         continue
#     fi
#     # results+=("${line}")
#     # results=$(echo "$results\n${line}")
#     # IFS=$'\n' grep_output=( $(echo "$line" | sed 's/ | /\n/') )
#     # 출력 공백 제거
#     # context=$(echo "${grep_output[2]}" | sed 's/\[K[ \t]*/\[K/g')
#     # results=$(echo "$results\n${context}    | ${grep_output[1]}")
#     # results=$(echo "$results\n${grep_output[2]}    | ${grep_output[1]}")
# done

alias fif="fzf --bind 'enter:become(command -v code >/dev/null 2>&1 && code {} || vi {})'"
# alias fnf="$HOME/.dotfiles/fzfscript/grepff"
# alias fmf="$HOME/.dotfiles/fzfscript/grepff -f"
alias gpf="$HOME/.dotfiles/fzfscript/grepff"
alias gpfh="$HOME/.dotfiles/fzfscript/grepff -f"
alias gph="$HOME/.dotfiles/fzfscript/grepff -f"
alias grepf="$HOME/.dotfiles/fzfscript/grepff"
alias grepfh="$HOME/.dotfiles/fzfscript/grepff -f"
alias greph="$HOME/.dotfiles/fzfscript/grepff -f"
alias grepff="$HOME/.dotfiles/fzfscript/grepff"

alias gnf="$HOME/.dotfiles/fzfscript/grepnfzf"
alias gff="$HOME/.dotfiles/fzfscript/grepnfzf"
alias gmf="$HOME/.dotfiles/fzfscript/grepmfzf"
alias gmff="$HOME/.dotfiles/fzfscript/grepmfzf"


# fzfcode
if [ -n "$(command -v fzf)" ]; then
    if (alias fzf >/dev/null 2>&1); then
        unalias fzf
    fi
    alias fzf="fzf -e --ansi --height 40% --layout=reverse --bind 'ctrl-a:half-page-up' --bind 'ctrl-d:half-page-down'"
    # if (declare -f -F "$@" > /dev/null); then
    #     unset -f fzf
    # fi
    # whence -p fzf # command in zsh
    # local FU_FZF_BIN_PATH="$(/bin/which fzf)"
    function faf() {
        # TODO : -m 등 옵션값 처리하지 못함. 해당 방법 모색
        # local FU_FZF_BIN_PATH="$(/bin/which fzf)"
        [ $# -ge 2 ] && echo "too many arguments" && return
        if [ $# -eq 1 ]; then
            if [ ! -d "$@" ]; then
                echo "$@ not directory"
                return
            fi
            builtin cd $@
            fzf -e --ansi --height 40% --layout=reverse --bind 'ctrl-a:half-page-up' --bind 'ctrl-d:half-page-down'
            builtin cd - > /dev/null
            return
        fi
        fzf -e --ansi --height 40% --layout=reverse --bind 'ctrl-a:half-page-up' --bind 'ctrl-d:half-page-down'
    }
fi

function didiff() {
    local codepath=vimdiff
    local codeopt=""
    [ -n "$(command -v code)" ] && codepath=code && codeopt="--diff"
    [ -n "$(command -v 'code-insiders')" ] && codepath=code-insiders && codeopt="--diff"
    if [ $# -ne 2 ]; then
        echo "wrong argument"
        return;
    fi
    if [ ! -f "$1" ];then
        echo "'$1' file is not exist"
        return
    fi
    if [ ! -f "$2" ];then
        echo "'$2' file is not exist"
        return
    fi
    $codepath $codeopt "$1" "$2"
}

function encoding_ls()
{
    find . -type f -exec grep -I -q . {} \; -print | xargs -I{} file -i {}
}

function encoding_euckr_to_utf8()
{
    # euc_krs=( $(find . -name "*" -type f -exec file -i {} \; | grep "iso-8859-1" | awk -F ":" '{print $1}') )
    # get not binary file list
    # euckrs=( $(find . -type f -exec grep -I -q . {} \; -print) )
    euc_krs=( $(find . -type f -exec grep -I -q . {} \; -print | xargs -I{} file -i {} | grep "iso-8859-1" | awk -F ":" '{print $1}') )
    for file in "${euc_krs[@]}" ; do
        echo "Converting $file to UTF-8"
        # euc-kr -> utf-8, save to test.c.new
        iconv -c -f euc-kr -t utf-8 "$file" > "$file.new"
        # remove test.c
        rm -f "$file"
        # mv test.c.new test.c
        mv "$file.new" "$file"
    done
}

# alias direj="di $(find . -name '*.rej' -type f | head -n 1 | sed 's/....$//') $(find . -name '*.rej' -type f | head -n 1)"
function direj()
{
    find_result=$(find . -name '*.rej' -type f)
    rej_file=$(echo "$find_result" | head -n 1)
    org_file=$(echo "$rej_file" | sed 's/....$//')
    echo "$rej_file"
    remains=$(echo "$find_result" | wc -l)
    echo "remain : $remains"
    di "$rej_file" "$org_file"
}

function mvrej()
{
    rej_file=$(find . -name '*.rej' -type f | head -n 1)
    echo "$rej_file"
    if [ ! -d $HOME/rej ]; then
        mkdir $HOME/rej/
    fi
    cp --parents $rej_file $HOME/rej/
    rm -f "$rej_file"
}

# rollback rej
function rbrej()
{
    res=$(find $HOME/rej -type f -printf "%T@ %p\n" | sort -n | tail -n1 | cut -d" " -f2-)
    if [ "$rej" = "" ]; then
        echo "empty in rej"
        return ;
    fi
    resto=."$(echo "$res" | sed "s|$HOME/rej||")"
    rb_path="$(dirname $resto)"
    echo $res
    mv "$res" "$rb_path"
}

function toucha() { touch $@; chmod 755 $@; }

function psv() {
    ps -aef | head -n 1
    ps -aef | grep "$@" | grep -v "grep --color=auto $@" | grep "$@"
}

function makectags() { ctags --tag-relative --langmap=C:.c.h.l.y --c-kinds=+p+l --languages=C --fields=+l $@ -f .tags --sort=foldcase -R ./*; }
function makepytags() { ctags --tag-relative --langmap=Python:.py --languages=Python --fields=+l $@ --sort=foldcase -R ./*; }
alias guifiles='vim -c :UpdateTypesFileOnly -c :q'
function maketaghl() {
    if [ ! -f ~/.vim/plugin/TagHighlight.vim ]; then
        echo "no TagHighlight.vim plugin"
        return
    fi
    test ! -f taghl_config.txt && touch taghl_config.txt
    echo "IncludeLocals:True" > taghl_config.txt
    echo "TagFileName:.tags" >> taghl_config.txt
    echo -n "UserLibraries:" >> taghl_config.txt
}

function clearsslkeylog() {
    if [ "$SSLKEYLOGFILE" = "" ]; then
        echo "SSLKEYLOGFILE is not defined"
        return
    fi

    echo -n "" > $SSLKEYLOGFILE
}

# find . ! \( -type d \( -path "./test1" -o -path "./test2" \) -prune \) -type f -and ! -name "LICENSE.txt" -and ! -name "readme.txt" -and -name "*.txt"
# alias findsrc='fualias() { find . ! \( -type d \( -path "./httpgw_oldssl" \) -prune \) -regex ".*\.\(c\|h\|y\|l\|py\)" -type f -exec grep -Hn --color "$@" {} \; ; }; fuinit'

# fd glob pattern
alias fdl="fd -H -t f -g"
alias fdi="fd -H -I"
function findsrc() {
    local ext="\(c\|cpp\|h\|y\|l\|py\)"
    find . ! \( -type d \( -path "./httpgw_oldssl" \) -prune \) -regex ".*\.$ext" -type f -exec grep -HnP --color=always "$@" {} \; |
    sed -e "/Binary file .* matches/d" |
    sed -e "s/\:\[m\[K\s*/ |[m[K /2"
    # sed -e "s/\:/ | /2" -e "s| \| \[m\[K\s*| \| [m[K|"
}

function afindsrc() {
    local curpwd=$(pwd)
    if [[ "$curpwd" != "/" ]]; then
        curpwd="${curpwd}/"
    fi
    local ext="\(c\|cpp\|h\|y\|l\|py\)"
    find . ! \( -type d \( -path "./httpgw_oldssl" \) -prune \) -regex ".*\.$ext" -type f -exec grep -HnP --color=always "$@" {} \; |
    sed -e "/Binary file .* matches/d" |
    sed -e "s|^|${curpwd}|1" -e "s|\:\[m\[K\s*|[m[K\n|2"
    # sed -e "s|^|${curpwd}|1" -e "s/\:/\n/2" -e "s|\n\[m\[K\s*|\n[m[K|"
}

function findex() {
    local curpwd=$(pwd)
    if [ $# -lt 2 ]; then
        echo "wrong argument"
        return ;
    fi
    if [[ "$curpwd" != "/" ]]; then
        curpwd="${curpwd}/"
    fi
    # argument get last index value
    keyword="${@:${#}:1}"
    # local ext="\($1"
    # fd - no \ char
    local ext="($1"

    local exts=()
    for _ext in "$@"; do
        exts+=("$_ext")
    done
    unset "exts[${#exts[@]}]"
    exts=("${exts[@]:1}")

    # local ext="\(c\|cpp\|h\|y\|l\|py\)"
    for (( i=1; i<${#exts[@]}; i++ )); do
        # ext+="\|${exts[$i]}"
        ext+="|${exts[$i]}"
    done
    unset exts
    # ext+="\)$"
    ext+=")$"

    # find . -regex ".*\.$ext" -type f -exec grep -HnP --color=always "$keyword" {} \; |
    fd --regex ".*\.$ext" --type file --color=never --follow --hidden --no-ignore -X grep -lI . |
    xargs -d '\n' -I{} grep -HnP --color=always "$keyword" {} |
    sed -e "s/\:\[m\[K\s*/ |[m[K /2"
}


function findexa() {
    local curpwd=$(pwd)
    if [ $# -lt 2 ]; then
        echo "wrong argument"
        return ;
    fi
    if [[ "$curpwd" != "/" ]]; then
        curpwd="${curpwd}/"
    fi
    keyword="${@:${#}:1}"
    # local ext="\($1"
    # fd - no \ char
    local ext="($1"

    local exts=()
    for _ext in "$@"; do
        exts+=("$_ext")
    done
    unset "exts[${#exts[@]}]"
    exts=("${exts[@]:1}")

    # local ext="\(c\|cpp\|h\|y\|l\|py\)"
    for (( i=1; i<${#exts[@]}; i++ )); do
        # ext+="\|${exts[$i]}"
        ext+="|${exts[$i]}"
    done
    unset exts
    # ext+="\)$"
    ext+=")$"

    # find . -regex ".*\.$ext" -type f -exec grep -HnP --color=always "$keyword" {} \; |
    fd --regex ".*\.$ext" --type file --color=never --follow --hidden --no-ignore -X grep -lI . |
    xargs -d '\n' -I{} grep -HnP --color=always "$keyword" {} |

    sed -e "s|^|${curpwd}|1" -e "s|\:\[m\[K\s*|[m[K\n|2"
}

function findall() { find . -name "*" -type f -exec grep -HnP --color "$@" {} \; ; }


function catcrlf() {
    if [ ! -f "$@" ]; then
        echo "file not found"
        return 1
    fi

    cat -A "$@" | sed 's/\$$/\r/'
}


function svndiff() {
    local SVN_REV=0
    local AGO_REV=0
    # if [[ $@ =~ "-" ]]; then
    if grep -q "-" <<< "$@"; then
        SVN_REV=`svn info | grep Revision | awk -F ': ' ' { print $2 } '`
        local REV_MINUS=`echo $@ | sed -e 's/\-//g'`
        SVN_REV=`expr \( ${SVN_REV} \- ${REV_MINUS} + 1 \)`
        AGO_REV=`expr \( ${SVN_REV} \- 1 \)`
        svn log -r $SVN_REV
    else
        SVN_REV=`echo $@ | cut -d ":" -f2 -s`
        AGO_REV=0
        if [[ $SVN_REV = "" ]]; then
            SVN_REV=$@
            AGO_REV=`expr \( ${SVN_REV} \- 1 \)`
            svn log -r $SVN_REV;
        else
            AGO_REV=`echo $@ | cut -d ":" -f1 -s`
            AGO_REV=`expr \( ${AGO_REV} \- 1 \)`
        fi
    fi
    svn diff -r$AGO_REV:$SVN_REV --summarize | sort;
}

# 관계가 없는 두 브랜치를 머지할 때 사용
# gitapplymacro "abcdefab..12345678" "main"
function gitapplymacro()
{
    commit_between="$1"
    apply_branch="$2"
    git_diff_path="/tmp/gitapplymacro.diff"
    rm -f "$git_diff_path"

    # diff beetween a and b
    git diff ${commit_between} > ${git_diff_path}

    # checkout apply branch
    git checkout ${apply_branch}

    # apply diff
    git apply --reject ${git_diff_path}

    echo "\n"
    echo "check /tmp/gitapplymacro.diff last content"

    echo "\n\n" >> ${git_diff_path}
    echo "========== reject file list ==========\n" >> ${git_diff_path}
    # find merge conflict file
    find . -name "*.rej" -type f >> ${git_diff_path}
    echo "" >> ${git_diff_path}

}


# gitdiff <option> <commit>
# gitdiff --name-only 12345678
# gitdiff --name-only 12345678..abcdefab
function gitdiff() {
    if [ $# -eq 0 ]; then
        git diff
        echo "================================================================"
        git diff --cached
        return 0
    fi

    # --name-only
    local opts=( )
    local commit="$@"
    if [ $# -ge 2 ]; then
        local array=( ${@} )
        local opts=( $(echo "${array[@]:0:${#array[@]}-1}") )
        commit=${@[-1]}
    fi

    if [ -z "$commit" ]; then
        echo "commit argument is empty"
        return 1
    fi

    # commits=$(echo "$commit" | tr ' ' '\n')
    commits=$(echo "$commit" | sed 's/\.\./\n/')
    commit_wcl=$(echo "$commits" | wc -l)

    local head_commit=""
    local tail_commit=""

    if [ $commit_wcl -eq 1 ]; then
        # local logs=$(git log --graph --date=format-local:"%Y-%m-%d %H:%M:%S" --pretty='%Cred%h%Creset %Cgreen(%ad)%Creset %C(bold blue)<%an>%Creset %C(auto)%d%Creset %n%s%n' -2 "$commit" )
        local logs=$(git log --graph --date=iso-local --pretty='%Cred%h%Creset - %s %Cgreen(%ad)%C(auto)%d%Creset %C(bold blue)<%an>%Creset' -2 "$commit")
        commits=$(echo "$logs" | awk -F ' ' '{ print $2 }')
        head_commit=$(echo "$commits" | head -n 1)
        tail_commit=$(echo "$commits" | tail -n 1)
    elif [ $commit_wcl -eq 2 ]; then
        # gitdiff "aaa..bbb"
        head_commit=$(echo "$commits" | tail -n 1) # bbb
        tail_commit=$(echo "$commits" | head -n 1) # aaa
    else
        echo "wrong diff hash argument (only 1 or 2)"
        return 1
    fi

    if [ -z "$head_commit" ] || [ -z "$tail_commit" ]; then
        echo "diff failed"
        return 1
    fi

    echo "diff $tail_commit -> $head_commit (diff : $(git rev-list --count ${tail_commit}..${head_commit}))"
    echo "\n"
    git diff ${opts[@]} "${tail_commit}..${head_commit}"
}

# echo $SSH_CONNECTION


function vsdiff() { svn diff $@ | vi -; }

function sdfile() {
    # svn diff | grep -E "\-\-\-\s.*(\(revision\s.*\)|\(nonexistent\))";
    svn status | grep "^A" --color=never;
    svn status | grep "^D" --color=never;
    svn status | grep "^M" --color=never;
}

function svnconflict() {
    if [ "$#" -ne 1 ]; then
        echo "wrong argument"
    fi
    svn remove --force "$@"
    svn resolve --accept=working "$@"
}

alias cc='clear'

function rmvimtmp() {
    find . -name ".*.sw*" -type f -exec rm -rf {} \;
    find . -name ".sw*" -type f -exec rm -rf {} \;
}

alias sendhttp='~/req.sh'

#memcheck
#ps -eo user,pid,ppid,rss,size,vsize,pmem,pcpu,time,comm --sort -rss | egrep "USER|health_check"
#ps -aeo user,pid,ppid,rss,size,vsize,pmem,pcpu,time,comm --sort -rss | egrep "USER|health_check"
#top -d 1 | egrep "PID|health_check"


# alias cme='fualias() { myname=`echo "$USER"`; sudo chown -R $myname:$myname $@ ; }; fuinit'
alias cme='fualias() { myname=`whoami`; sudo chown -R $myname $@ ;  }; fuinit'

AGO_SFTP_DEBUG_PROCESS=""
function gdbs() {
    [ -n "$(pidof gdbserver)" ] && pkill -f gdbserver
    if [[ "$@" != "" ]]; then
        if [[ "$@" = "httpgw" ]]; then
            . ../.vscode/debugger.sh httpgw 0
            # source ../.vscode/debugger.sh httpgw 0
        fi
        gdbserver :9091 ./"$@" &
        AGO_SFTP_DEBUG_PROCESS="$@"
    else
        if [ -n "$AGO_SFTP_DEBUG_PROCESS" ]; then
            if [[ "$AGO_SFTP_DEBUG_PROCESS" = "httpgw" ]]; then
                . ../.vscode/debugger.sh httpgw 0
                # source ../.vscode/debugger.sh httpgw 0
            fi
            gdbserver :9091 ./"$AGO_SFTP_DEBUG_PROCESS" &
        else
            echo "no argument"
        fi
    fi
}
alias kgdb='pkill -f gdbserver'


function cpdown() {
    cp -r $@ ~/download/
}

# 256 색상 인덱스를 hex 코드로 변환하는 함수
function xterm_to_hex() {
    local index=$1
    local r g b

    # Validate input
    if ! [[ "$index" =~ ^[0-9]+$ ]] || [ "$index" -lt 0 ] || [ "$index" -gt 255 ]; then
        echo "Error: Color index must be an integer between 0-255" >&2
        return 1
    fi

    # Standard 16 colors (0-15)
    if [ "$index" -lt 16 ]; then
        case $index in
            0)  r=0;   g=0;   b=0   ;; # black
            1)  r=128; g=0;   b=0   ;; # red
            2)  r=0;   g=128; b=0   ;; # green
            3)  r=128; g=128; b=0   ;; # yellow
            4)  r=0;   g=0;   b=128 ;; # blue
            5)  r=128; g=0;   b=128 ;; # magenta
            6)  r=0;   g=128; b=128 ;; # cyan
            7)  r=192; g=192; b=192 ;; # white
            8)  r=128; g=128; b=128 ;; # bright black (gray)
            9)  r=255; g=0;   b=0   ;; # bright red
            10) r=0;   g=255; b=0   ;; # bright green
            11) r=255; g=255; b=0   ;; # bright yellow
            12) r=0;   g=0;   b=255 ;; # bright blue
            13) r=255; g=0;   b=255 ;; # bright magenta
            14) r=0;   g=255; b=255 ;; # bright cyan
            15) r=255; g=255; b=255 ;; # bright white
        esac
    # 6x6x6 color cube (16-231)
    elif [ "$index" -lt 232 ]; then
        local color_idx=$(($index - 16))
        # The RGB components in the 6x6x6 cube increase in steps of 40 (except 0), resulting in:
        # 0, 95, 135, 175, 215, 255
        r=$(( (color_idx / 36) ))
        g=$(( (color_idx % 36) / 6 ))
        b=$(( color_idx % 6 ))

        # Convert to actual RGB values
        r=$(( r == 0 ? 0 : r * 40 + 55 ))
        g=$(( g == 0 ? 0 : g * 40 + 55 ))
        b=$(( b == 0 ? 0 : b * 40 + 55 ))
    # Grayscale (232-255)
    else
        # Grayscale values start at 8 and increment by 10
        r=$(( (index - 232) * 10 + 8 ))
        g=$r
        b=$r
    fi

    # Format as hex
    printf "#%02x%02x%02x\n" $r $g $b
}

alias colorpreview='for i in {0..255}; do print -Pn "%K{$i} %k%F{$i}${(l:3::0:)i} $(xterm_to_hex $i )%f " ${${(M)$((i%6)):#3}:+\\n}; done'

alias sshclear='pkill -f "sshd:.*$USER.*\\@"'
alias sshclearall='pkill -f "sshd:.*\\@"'

function pytest() {
    pytest $@;

    if [ -d __pycache__ ]; then
        rm -rf __pycache__/;
    fi

    if [ -d .pytest_cache ]; then
        rm -rf .pytest_cache/;
    fi
}

function splitlog() {
    logpath=""
    split_name=""
    line=100000
    if [ "$(command -v split)" = "" ]; then
        echo "split command not exist"
        return
    fi

    if [ $# -eq 0 ] || [ $# -gt 3 ];then
        echo "wrong argument"
        return
    fi

    if [ $# -eq 1 ]; then
        logpath="$1"
        split_name=$(basename "$logpath")
    elif [ $# -eq 2 ]; then
        line=$1
        logpath="$2"
        split_name=$(basename "$logpath")
    elif [ $# -eq 3 ]; then
        line=$1
        logpath="$2"
        split_name="$3"
    fi
    if [ ! -f "$logpath" ]; then
        echo "file not exist"
        return
    fi

    if [ -d "spdir_${split_name}" ]; then
        echo "already split content exist"
        return
    fi
    mkdir "spdir_${split_name}"
    split -l $line -d --additional-suffix=.log "$logpath" "spdir_${split_name}/${split_name}_"
}


# wiki alias =============================

alias dotfiles='cd $HOME/.dotfiles'
alias jtodo='di $HOME/iblea.github.io/wiki/jtodo.md'
function gowiki() { cd ~/iblea.github.io/wiki/$@; }
function gomantis() { cd ~/iblea.github.io/wiki/issue/issue_note/mantis/$@; }
# alias wifind='fualias() { find ~/iblea.github.io/wiki/ -name "*.md" -type f -exec grep --color=always -HnP $@ {} \; | sed -e "p" -e "s/:/ | /2" | sed -n "2~2p" }; fuinit'
function wifind() {
    local blog_dir=~/iblea.github.io/wiki/
    if [ ! -d $blog_dir ]; then
        echo "no blog dir"
        return
    fi
    builtin cd $blog_dir;
    grep --color=always -rnIHP --include="*.md" $@ ./ | sed -e "p" -e "s/:/ | /2" | sed -n "2~2p"
    builtin cd - > /dev/null ;
}

function wnfind() {
    local blog_dir=~/iblea.github.io/wiki/
    test -d $blog_dir && find $blog_dir -type f -name "*.md" | grep "$@"
}





# docker alias ==============================
# sh - docker - origin
function docbash() {
    if [ $# -eq 1 ]; then
        homedir=$(docker exec -u 0 "$1" env | grep "^HOME=" | awk -F 'HOME=' '{print $2}')
        if [[ "$homedir" = "" ]]; then
            homedir="/"
        fi
        docker exec -u 0 -w $homedir -it "$1" bash
    elif [ $# -eq 2 ]; then
        homedir=$(docker exec -u 0 "$1" env | grep "^HOME=" | awk -F 'HOME=' '{print $2}')
        if [[ "$homedir" = "" ]]; then
            homedir="/"
        fi
        docker exec -u $2 -w $homedir -it "$1" bash
    else
        echo "wrong argument"
        return
    fi
}

# sh - docker
function docsh() {
    if [ $# -eq 1 ]; then
        homedir=$(docker exec -u 0 "$1" env | grep "^HOME=" | awk -F 'HOME=' '{print $2}')
        if [[ "$homedir" = "" ]]; then
            homedir="/"
        fi
        docker exec -u 0 -w $homedir -it "$1" zsh
    elif [ $# -eq 2 ]; then
        homedir=$(docker exec -u $2 "$1" env | grep "^HOME=" | awk -F 'HOME=' '{print $2}')
        if [[ "$homedir" = "" ]]; then
            homedir="/"
        fi
        docker exec -u $2 -w $homedir -it "$1" zsh
    else
        echo "wrong argument"
        return
    fi
}

function docps {
    docker ps --format "table {{.ID}}\t{{.Image}}\t{{.Status}}\t{{.Names}}" $@
}





# git alias ==============================

if [ -n "$(locale -a 2>/dev/null | grep 'en_US.UTF-8')" ]; then
    alias git="LANG=en_US.UTF-8 git"
elif [ -n "$(locale -a 2>/dev/null | grep 'en_US.utf8')" ]; then
    alias git="LANG=en_US.utf8 git"
fi

alias delspace="sed -i 's/\s\+$//g'"
alias delspaceall="grep -rlI . | xargs -d '\n' -I{} sed -i 's/\s\+$//g' {}"
# 문장 뒤 공백 제거
# xargs
# grep -rlI . | xargs -d '\n' -I{} sed -i 's/\s\+$//g' {}
# find
# find ./ -xdev -type f -exec grep -rlI . {} \; -exec sed -i 's/\s\+$//g' {} \; > /dev/null

# git alias
if [ ! -f ~/.gitconfig ]; then
    git config --global alias.co checkout
    git config --global alias.bb "\!$HOME/.dotfiles/script/better_branch.sh"
    git config --global alias.br branch
    git config --global alias.ci commit
    git config --global alias.st status
    git config --global alias.last 'log -1 HEAD'

    # Git 편집 에디터 변경
    git config --global core.editor "vim"
    # Git 원격 저장소에서 삭제된 branch를 로컬 저장소에서 자동으로 지우기

    git config --global fetch.prune true
    git config --global push.default current
    git config --global pull.rebase true
    git config --global rerere.enabled true
    git config --global column.ui never
    git config --global branch.sort -committerdate
    git config --global core.excludesFile "~/.dotfiles/gitignore_global"
    # signed commit
    # git config gpg.format ssh
    # git config user.signingkey ~/.ssh/key.pub
    # git commit -S
    # git push --signed

    # git commit-graph write
    git config --global fetch.writeCommitGraph true
    git config --global core.quotepath false

    # git config -global core.untrackedcache true
    # git config -global core.fsmonitor true
    # git config --global --filter=blob:none
    # git config --global --filter=tree:0
    # git sparse-checkout set build base

    # encoding
    git config --global i18n.commitencoding "UTF-8"
    git config --global i18n.logoutputencoding "UTF-8"

    git config --global core.sshCommand "ssh -i $HOME/.ssh/id_rsa -o StrictHostKeyChecking=no -o AddKeysToAgent=yes"

    # diff, merge
    git config --global diff.tool bcompare
    git config --global diff.euckr.textconv "iconv -f euc-kr -t utf-8"
    git config --global merge.tool bcompare
    git config --global difftool.bcompare.cmd "$HOME"/'.bcomp.sh "$LOCAL" "$REMOTE"'
    git config --global difftool.bcompare.trustExitCode true
    git config --global mergetool.bcompare.cmd "$HOME"/'.bcomp.sh "$LOCAL" "$REMOTE" "$BASE" "$MERGED"'
    git config --global mergetool.bcompare.trustExitCode true
    git config --global mergetool.bcompare.keepBackup false
fi


# gb -> git branch
# gba -> git branch -a (git branch --all)
# gco -> git checkout
# gci -> git commit
# gbv -> git branch -vv
# gs, gst ->  git status
# gsti  ->  git stash
# gsb -> git status -sb
# gr -> git remote
# grb -> git rebase
# grev -> git revert
# gsh -> git reset
# grs -> git restore


function fuunalias_alias()
{
    local alias_name=$1
    local cmd=$2
    local is_cmd=`alias | grep "\<$alias_name\>="`
    if [ -n "$is_cmd" ]; then
        unalias $alias_name
    fi
    if [ -n "$cmd" ]; then
        alias $alias_name="$cmd"
    fi
}


fuunalias_alias 'gb' 'git branch'
fuunalias_alias 'gba' 'git branch --all'
fuunalias_alias 'gco' 'git checkout'
fuunalias_alias 'gsh' 'git reset'
fuunalias_alias 'grs' 'git restore'
fuunalias_alias 'gcf' 'git config'
fuunalias_alias 'gcfl' 'git config --list'
fuunalias_alias 'gs' 'git status --short'
fuunalias_alias 'gst' 'git status'
fuunalias_alias 'gsa' 'git status --short ./'
fuunalias_alias 'gsti' 'git stash push'
# push stash untracked file
fuunalias_alias 'gstiu' 'git stash push -u'
# keep staging file
fuunalias_alias 'gstik' 'git stash push -k'
fuunalias_alias 'gstiku' 'git stash push -k -u'
fuunalias_alias 'gstmp' ''
fuunalias_alias 'gsta' ''
fuunalias_alias 'gstai' ''
fuunalias_alias 'gstc' 'git checkout stash -- .'
fuunalias_alias 'gstclr' 'git stash clear'
fuunalias_alias 'gstl' 'git stash list'
fuunalias_alias 'gstia' 'git stash push -k -u'
fuunalias_alias 'gsm' 'git submodule'
fuunalias_alias 'gbv' 'git branch -vv'
fuunalias_alias 'gu' 'git push'
fuunalias_alias 'gp' 'git pull'
# merge no commit no ff (squash - no commit)
fuunalias_alias 'gmn' 'git merge --no-commit --no-ff'
fuunalias_alias 'gmns' 'git merge --squash --no-commit'
# fatal: refusing to merge unrelated histories - 관련 기록이 없는 두 이질적인 프로젝트 병합
fuunalias_alias 'gmnsah' 'git merge --squash --no-commit --allow-unrelated-histories'
fuunalias_alias 'grevtme' 'git revert --no-edit --no-commit'
fuunalias_alias 'gl' ''
fuunalias_alias 'gsi' ''
# fuunalias_alias 'gpf' ''
fuunalias_alias 'gpsh' 'git push'
fuunalias_alias 'gpshfl' 'git push --force-with-lease'
fuunalias_alias 'gpshfc' 'git push --force'
fuunalias_alias 'gcpick' 'git cherry-pick'
fuunalias_alias 'gcpicknci' 'git cherry-pick --no-commit'

# fuunalias_alias 'gci' 'git commit'
fuunalias_alias 'gci' ''

function gci() {
    if [ $# -eq 0 ]; then
        git commit -v
        return 0
    fi

    git commit $@
}



function gstai() {
    if [[ "$@" = "" ]]; then
        git stash apply
    else
        git stash apply stash@{$@}
    fi
}
alias gsta='gstai'
function gstac() {
    if [ $# -eq 0 ]; then
        echo "wrong argument"
        return
    fi
    if [ $# -eq 1 ]; then
        git checkout stash@{0} "$1"
        return
    fi

    for arg in "${@:2}"; do
        git checkout stash@{$1} "$arg"
    done

}

# 가장 최근에 저장된 stash의 번호는 0번이다.
function gstmp() {
    if [[ "$@" = "" ]]; then
        git stash push -k -u
    else
        git stash push -k -u $@
    fi
    git stash apply stash@{0}

    echo ""
    echo ""
    echo "stash list"
    git stash list
    echo ""
}

function gsl() {
    gitroot=$(git rev-parse --show-toplevel 2>/dev/null)
    if [ $? -ne 0 ] || [ -z "$gitroot" ]; then
        echo "not git repo"
        return 1
    fi

    if [ ! -d "${gitroot}/.git" ]; then
        echo "not git directory in repo"
        return 1
    fi

    if [ ! -d "${gitroot}/.git/svn" ]; then
        echo "not svn directory in repo"
        return 1
    fi

    git svn log --limit 10 $@ 2>/dev/null
}

function gsla() {
    gitroot=$(git rev-parse --show-toplevel 2>/dev/null)
    if [ $? -ne 0 ] || [ -z "$gitroot" ]; then
        echo "not git repo"
        return 1
    fi

    if [ ! -d "${gitroot}/.git" ]; then
        echo "not git directory in repo"
        return 1
    fi

    if [ ! -d "${gitroot}/.git/svn" ]; then
        echo "not svn directory in repo"
        return 1
    fi

    git svn log $@ 2>/dev/null
}


function gl() {

    # git log --graph --pretty='\''%Cred%h%Creset - %s %Cgreen(%ad)%C(auto)%d%Creset %C(bold blue)<%an>%Creset'\'' $@
    local AGO_LC_ALL="$LC_ALL"
    if [ "$(locale -a 2>/dev/null | grep 'ko_KR.UTF-8')" ]; then
        export LC_ALL=ko_KR.UTF-8
    elif [ "$(locale -a 2>/dev/null | grep 'ko_KR.utf8')" ]; then
        export LC_ALL=ko_KR.utf8
    fi

    # --date=iso-local
    git log --graph \
    --date=format-local:"%Y-%m-%d %H:%M:%S" \
    --pretty='%Cred%h%Creset %Cgreen(%ad)%Creset %C(bold blue)<%an>%Creset %C(auto)%d%Creset %n%s%n' \
    -5 $@
    export LC_ALL="$AGO_LC_ALL"
}

function gla() {
    # git log --graph --pretty='\''%Cred%h%Creset - %s %Cgreen(%ad)%C(auto)%d%Creset %C(bold blue)<%an>%Creset'\'' $@
    local AGO_LC_ALL="$LC_ALL"
    if [ "$(locale -a 2>/dev/null | grep 'ko_KR.UTF-8')" ]; then
        export LC_ALL=ko_KR.UTF-8
    elif [ "$(locale -a 2>/dev/null | grep 'ko_KR.utf8')" ]; then
        export LC_ALL=ko_KR.utf8
    fi
    git log --graph \
    --date=format-local:"%Y-%m-%d %H:%M:%S" \
    --pretty='%Cred%h%Creset %Cgreen(%ad)%Creset %C(bold blue)<%an>%Creset %C(auto)%d%Creset %n%s%n' \
    $@
    export LC_ALL="$AGO_LC_ALL"
}

function glv() {
    local AGO_LC_ALL="$LC_ALL"
    if [ "$(locale -a 2>/dev/null | grep 'ko_KR.UTF-8')" ]; then
        export LC_ALL=ko_KR.UTF-8
    elif [ "$(locale -a 2>/dev/null | grep 'ko_KR.utf8')" ]; then
        export LC_ALL=ko_KR.utf8
    fi
    # --pretty='%Cred%H%Creset %Cgreen%ad%Creset%C(auto)%d%Creset %n%C(bold blue) <%an> [%ce] %Creset %n%B%n' \
    git log --date=iso-local --graph \
    --pretty='%Cred%H%Creset %Cgreen%ad%Creset%C(auto)%d%Creset %n%C(bold blue)<%an> [%ce] %Creset %n%B%n' \
    -3 $@
    export LC_ALL="$AGO_LC_ALL"
}

function glva() {
    # git log --graph --pretty='\''%Cred%h%Creset - %s %Cgreen(%ad)%C(auto)%d%Creset %C(bold blue)<%an>%Creset'\'' $@
    local AGO_LC_ALL="$LC_ALL"
    if [ "$(locale -a 2>/dev/null | grep 'ko_KR.UTF-8')" ]; then
        export LC_ALL=ko_KR.UTF-8
    elif [ "$(locale -a 2>/dev/null | grep 'ko_KR.utf8')" ]; then
        export LC_ALL=ko_KR.utf8
    fi
    # --pretty='%Cred%H%Creset %Cgreen%ad%Creset%C(auto)%d%Creset %n%C(bold blue) <%an> [%ce] %Creset %n%B%n' \
    git log --date=iso-local --graph \
    --pretty='%Cred%H%Creset %Cgreen%ad%Creset%C(auto)%d%Creset %n%C(bold blue)<%an> [%ce] %Creset %n%B%n' \
    $@
    export LC_ALL="$AGO_LC_ALL"
}

function glc() {
    # git log --graph --pretty='\''%Cred%h%Creset - %s %Cgreen(%ad)%C(auto)%d%Creset %C(bold blue)<%an>%Creset'\'' $@
    local AGO_LC_ALL="$LC_ALL"
    if [ "$(locale -a 2>/dev/null | grep 'ko_KR.UTF-8')" ]; then
        export LC_ALL=ko_KR.UTF-8
    elif [ "$(locale -a 2>/dev/null | grep 'ko_KR.utf8')" ]; then
        export LC_ALL=ko_KR.utf8
    fi
    gitoutput=$(
        git log --graph \
            --date=format-local:"%Y-%m-%d %H:%M:%S" \
            --pretty='%Cred%h%Creset %Cgreen(%ad)%Creset %C(bold blue)<%an>%Creset %C(auto)%d%Creset %n%B' \
        $@
    )
    if [ "$(command -v di)" ]; then
        echo "$gitoutput" | di -
    elif [ "$(command -v code)" ]; then
        echo "$gitoutput" | code -
    else
        echo "$gitoutput" | vi -

    fi
    export LC_ALL="$AGO_LC_ALL"
}



# glr
# glr <option1> <option2>
# glr <option1> <option2> ... <remote name - ex ) origin>
function glr() {
    local remote_branch="$(git rev-parse --abbrev-ref HEAD)"
    if [[ "${remote_branch}" = "HEAD" ]]; then
        echo "failed to get remote branch name"
        exit 1
    fi

    local opts=""
    local remotes=""
    if [ $# -eq 0 ]; then
        remotes="origin"
    else
        remotes="${@:${#}:1}"
        if [[ "${remotes:0:1}" = "-" ]]; then
            opts=( $@ )
            remotes="origin"
        else
            # $@ 에서 두 번째 인자부터 끝까지 배열로 저장
            # opts=(${@:2:${#}-1})
            # $@ 에서 첫 번째 인자부터 끝-1 까지 배열로 저장
            opts=(${@:1:${#}-1})
        fi
    fi
    local AGO_LC_ALL="$LC_ALL"
    if [ "$(locale -a 2>/dev/null | grep 'ko_KR.UTF-8')" ]; then
        export LC_ALL=ko_KR.UTF-8
    elif [ "$(locale -a 2>/dev/null | grep 'ko_KR.utf8')" ]; then
        export LC_ALL=ko_KR.utf8
    fi
    git log --graph \
    --date=format-local:"%Y-%m-%d %H:%M:%S" \
    --pretty='%Cred%h%Creset %Cgreen(%ad)%Creset %C(bold blue)<%an>%Creset %C(auto)%d%Creset %n%s%n' \
    $opts "remotes/${remotes}/${remote_branch}"

    export LC_ALL="$AGO_LC_ALL"
}



function gld() {
    local AGO_LC_ALL="$LC_ALL"
    if [ "$(locale -a 2>/dev/null | grep 'ko_KR.UTF-8')" ]; then
        export LC_ALL=ko_KR.UTF-8
    elif [ "$(locale -a 2>/dev/null | grep 'ko_KR.utf8')" ]; then
        export LC_ALL=ko_KR.utf8
    fi

    if [ $# -eq 0 ]; then
        git log --graph \
        --date=format-local:"%Y-%m-%d %H:%M:%S" \
        --pretty='%Cred%h%Creset %Cgreen(%ad)%Creset %C(bold blue)<%an>%Creset %C(auto)%d%Creset %n%s%n' \
        ./
    else
        if [[ "$1" = "/" ]]; then
            git log --graph \
            --date=format-local:"%Y-%m-%d %H:%M:%S" \
            --pretty='%Cred%h%Creset %Cgreen(%ad)%Creset %C(bold blue)<%an>%Creset %C(auto)%d%Creset %n%s%n' \
            ${@:2}
        elif [[ "${1:0:1}" = "-" ]]; then
            git log --graph \
            --date=format-local:"%Y-%m-%d %H:%M:%S" \
            --pretty='%Cred%h%Creset %Cgreen(%ad)%Creset %C(bold blue)<%an>%Creset %C(auto)%d%Creset %n%s%n' \
            $@ ./
        else
            git log --graph \
            --date=format-local:"%Y-%m-%d %H:%M:%S" \
            --pretty='%Cred%h%Creset %Cgreen(%ad)%Creset %C(bold blue)<%an>%Creset %C(auto)%d%Creset %n%s%n' \
            $@
        fi
    fi

    export LC_ALL="$AGO_LC_ALL"
}

alias gitsync='git remote update origin --prune'
function gitsvnrev() {

    local revinf="$@"
    if [[ "${revinf:0:1}" = "r" ]]; then
        branches=$(git for-each-ref --format='%(refname)' refs/heads/ | sed 's|^refs/heads/||')
        IFS=$'\n' branches=( $(echo "$branches") )
        for branch in $branches ; do
            local inform=$(git svn find-rev $@ $branch 2>/dev/null)
            if [[ "$inform" = "" ]]; then
                continue
            fi
            echo "branch (${branch}) : ${inform}"
        done
        return 0
    fi

    hash="${revinf}"
    if [[ "${revinf}" = "" ]]; then
        hash=$(git log --pretty=format:%H --max-count 1)
    elif [[ "${revinf}" = "./" ]]; then
        hash=$(git log --pretty=format:%H --max-count 1 ./ )
    elif [[ $# -ge 2 ]] && [[ "$1" = "-p" ]]; then
        hash=$(git log --pretty=format:%H --max-count 1 "$2" )
    fi

    if [ -z "$hash" ]; then
        echo "cannot find commit hash"
        return 0
    fi
    git svn find-rev "$hash"
}

# [svn-remote "v5.0"]
#     url = svn://1.1.1.1/test/v5.0
#     fetch = :refs/remotes/origin/develop
# [svn-remote "v5.0.2"]
#     url = svn://1.1.1.1/test/v5.0.2_2
#     fetch = :refs/remotes/origin/main

function gitsvnrevb() {
    if [ $# -le 1 ]; then
        git svn find-rev $@ $(git rev-parse --abbrev-ref HEAD) 2>/dev/null
    elif [ $# -eq 2 ]; then
        git svn find-rev $1 $2 2>/dev/null
    else
        git svn find-rev $(git log remotes/origin/$@ --max-count 1 --pretty=format:%H) 2>/dev/null
    fi
}

alias gital='alias | grep "^g.*git"'

alias gdd='git diff | grep "\<printf\>"'

# gitstatsd - git stats debug
# zsh -dfxic 'GITSTATUS_ENABLE_LOGGING=1 && source ~/.zsh/.oh-my-zsh/custom/themes/powerlevel10k/gitstatus/gitstatus.plugin.zsh && gitstatus_start MY && gitstatus_query MY && cat $GITSTATUS_DAEMON_LOG_M'

# git svn fetch error (untracked file)
alias gitup='git update-index --assume-unchanged'
alias gitupa='git update-index --really-refresh'
function gitupall() {
git status -s | awk -F ' ' '{print $2}' | xargs git update-index --assume-unchanged
git update-index --really-refresh
# git status -s | awk -F ' ' '{print $2}' | xargs git update-index --really-refresh
}

function gitsvnfetchall() {
    branches=( $(git config --local --list | grep "^svn-remote\..*\.url=.*" | awk -F '.' '{ print $2 }' | sort -u) )
    for branch in "${branches[@]}"; do
        echo "fetch branch : \"$branch\""
        git svn fetch "$branch"
    done

    echo ""
    echo "done"
    echo ""
    echo "you can execute the command"
    echo "git svn rebase"
}

function gsvnup() {
    if [ "$(git config --list | grep svn)" = "" ]; then
        return
    fi
    rev="$@"
    rev_hash=$(git svn find-rev "$rev" $(git rev-parse --abbrev-ref HEAD))
    git checkout "$rev_hash"
}

# 모든 변경사항 pull
function pullall() {
    local branch=origin
    if [ $# -eq 1 ]; then
        branch=$1
    fi
    git branch -r | grep -v "\->" | while read remote; do git branch --track "${remote#${branch}/}" "$remote"; done
    git branch -r | grep -v "\->" | while read remote; do git branch --set-upstream-to="$remote" "${remote#${branch}/}"; done
    git fetch --all
    git pull --all
}
alias missmerge='grep -rnI "\s*<<<<<<< "'

function gconflictundo()
{
    con_path=$@
    if [[ $con_path = "" ]]; then
        con_path=.
    fi
    # git status -s $con_path | grep "^AA " | awk -F '\''AA '\'' '\'' { print $2 } '\'' | xargs -I {} echo {}
    git status -s $con_path | grep "^AA " | awk -F 'AA ' ' { print $2 } ' | xargs -I {} git checkout --merge {}
}

# git reset conflict
function grsco()
{
    merge_list=$(gst --short | grep UU | sed 's/^UU //')
    echo "$merge_list"
    echo "$merge_list" | xargs -I {} git reset {}
}


function greverts()
{
    revert_list=( "${@}" )
    for revert_hash in "${revert_list[@]}"; do
        git revert --no-edit --no-commit "$revert_hash"
    done
}

# git status -s . | grep "^AA " | awk -F 'AA ' ' { print $2 } ' | xargs -I {} git checkout --merge {}

# git note =====================================================================

# git commit message 수정
# git commit --amend -m "message"

# git orphan branch 머지
# git merge --allow-unrelated-histories -X theirs a(merge apply) b (merge target)
# git merge --allow-unrelated-histories --squash feature/waf50 remotes/svn/git-svn
# ->  feature/waf50에 remotes/svn/git-svn 변경사항이 적용됨 (squash를 적용했기 때문에 커밋 로그는 하나로 합쳐짐)

# git remote에서 삭제된 브랜치 동기화하기
# git remote prune origin

# git merge (origin branch) (target branch)
# git co --ours dir/* -> origin branch 변경사항 적용 (현재 브랜치 내용 적용) (gco -2 dir/*)
# git co --theirs dir/* -> target branch 변경사항 적용 (브랜치 머지내용 적용) (gco -3 dir/*)
# git co --merge dir/* -> 충돌때로 undo (gco -m dir/*)
# 충돌때로 undo 시 에러가 나면 (현재 경로)
# git status -s . | grep "^AA " | awk -F 'AA ' ' { print $2 } ' | xargs -I {} git checkout --merge {}

# git-svn
# git svn init svn://1.1.1.1/REPO/v5.0 --prefix=svn/
# git svn fetch
# git checkout -b git-svn remotes/svn/git-svn
# git push origin git-svn

# git-svn fetch and dcommit
# git svn fetch v5.0
# git checkout waf50
# git merge --hard origin/waf50   or   git reset --merge orogin/waf50   or   git rebase remotes/origin/waf50
# git svn dcommit --username username

# ==============================================================================

alias dateunix='date "+%s"'
function unixtimeint() {
    if [ $# -ne 1 ]; then
        echo "wrong argument"
        return 1;
    fi
    date -d @$@ "+%Y-%m-%d %H:%M:%S"
}
function unixtimedate() {
    if [ $# -eq 1 ]; then
        date -d "$@" +%s
    elif [ $# -eq 6 ]; then
        read fyear_ fmonth_ fday_ fhour_ fmin_ fsec_ <<< "$@"
        # 2006-01-02 15:04:05
        date -d "${fyear_}-${fmonth_}-${fday_} ${fhour_}:${fmin_}:${fsec_}" +%s
        unset fyear_
        unset fmonth_
        unset fday_
        unset fhour_
        unset fmin_
        unset fsec_
    else
        echo "wrong argument."
        echo "write format \"2006-01-02 15:04:05\" or \"2006 01 02 15 04 05\""
        return 1
    fi
    return 0
}


alias ㅣ='ls -shCF -w 60'
alias ㅣㅣ='ls -lhF'
alias ㅣㅣㅁ='ls -alhF'
alias ㅊㅇ='cd'
alias 퍄='vim'
alias ㄷ턋='exit'
alias 야='di'
alias dk='di'
alias 아='di'
alias ㄴ헷='sgpt'
alias sgptc='sgpt --code'
alias ㄴ헷ㅊ='sgpt --code'

# td set eth1
# td 80
# td 80 tcp -w packet.pcap
function td()
{
    if [ -z "$td_iface" ]; then
        echo "not 'td_iface' set"
        td_iface="eth0"
    fi

    if [ $# -eq 0 ]; then
        echo "wrong argument tcpdump"
        echo "current show iface : '$td_iface'"
        return 1
    elif [ $# -eq 1 ]; then
        tcpdump -nn -vv -i "$td_iface" tcp port $@
    elif [ $# -eq 2 ] && [[ "$1" = "set" ]]; then
        echo "set td_iface=$2"
        td_iface="$2"
        return 0
    else
        # 5문자 뒤 문자를 출력 (ex. "qwertyasdf" -> "yasdf")
        # local opt=( $(echo "$@" | cut -c5- ) )
        # ' ' 문자를 기준으로 3번째부터 출력 ("a b c d" -> "c d")
        # local opt=$(echo "$@" | cut -d ' ' -f 3-)
        # 3번째부터 출력 : bash나 zsh나 동일
        for arg in "${@:3}"; do
            opt+=("$arg")
        done
        tcpdump -nn -vv -i "$td_iface" $2 port $1 ${opt[@]}
    fi
}

function idump()
{
    if [ ! -f $HOME/inetdump ]; then
        echo "cannot find $HOME/inetdump"
        return
    fi
    $HOME/inetdump
}

# alias
[ -f $HOME/.aliases_company ] && source ~/.aliases_company


return 0

